import '../common/common.dart';
export '../common/common.dart';
import '../soap-envelope/soap-envelope.dart';
import '../b-2/b-2.dart';

/// GENERATED BY OZIBABA
import 'dart:typed_data';
import 'package:json_annotation/json_annotation.dart';

/// Base class for physical entities like inputs and outputs.
@JsonSerializable()
class DeviceEntity {
  /// Unique identifier referencing the physical entity.
  @JsonKey(name: 'token')
  final ReferenceToken token;
  DeviceEntity({
    required this.token,
  });
}

/// User readable name. Length up to 64 characters.
@JsonSerializable()
class Name {
  @JsonKey(name: 'val')
  final String val;
  Name({
    required this.val,
  });
}

/// Rectangle defined by lower left corner position and size. Units are pixel.
@JsonSerializable()
class IntRectangle {
  @JsonKey(name: 'x')
  final int x;
  @JsonKey(name: 'y')
  final int y;
  @JsonKey(name: 'width')
  final int width;
  @JsonKey(name: 'height')
  final int height;
  IntRectangle({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });
}

/// Range of a rectangle. The rectangle itself is defined by lower left corner position and size. Units are pixel.
@JsonSerializable()
class IntRectangleRange {
  /// Range of X-axis.
  @JsonKey(name: 'XRange')
  final IntRange xRange;

  /// Range of Y-axis.
  @JsonKey(name: 'YRange')
  final IntRange yRange;

  /// Range of width.
  @JsonKey(name: 'WidthRange')
  final IntRange widthRange;

  /// Range of height.
  @JsonKey(name: 'HeightRange')
  final IntRange heightRange;
  IntRectangleRange({
    required this.xRange,
    required this.yRange,
    required this.widthRange,
    required this.heightRange,
  });
}

/// Range of values greater equal Min value and less equal Max value.
@JsonSerializable()
class FloatRange {
  @JsonKey(name: 'Min')
  final double min;
  @JsonKey(name: 'Max')
  final double max;
  FloatRange({
    required this.min,
    required this.max,
  });
}

/// Range of duration greater equal Min duration and less equal Max duration.
@JsonSerializable()
class DurationRange {
  @JsonKey(name: 'Min')
  final Duration min;
  @JsonKey(name: 'Max')
  final Duration max;
  DurationRange({
    required this.min,
    required this.max,
  });
}

/// List of values.
@JsonSerializable()
class IntList {
  @JsonKey(name: 'Items')
  final int? items;
  IntList({
    this.items,
  });
}

typedef IntAttrList = List<int>;

typedef FloatAttrList = List<double>;

typedef StringAttrList = List<String>;

typedef ReferenceTokenList = List<ReferenceToken>;

@JsonSerializable()
class FloatList {
  @JsonKey(name: 'Items')
  final double? items;
  FloatList({
    this.items,
  });
}

@JsonSerializable()
class StringItems {
  @JsonKey(name: 'Item')
  final String item;
  StringItems({
    required this.item,
  });
}

class AnyHolder {}

/// Representation of a physical video input.
class VideoSource {}

@JsonSerializable()
class VideoSourceExtension {
  /// Optional configuration of the image sensor. To be used if imaging service 2.00 is supported.
  @JsonKey(name: 'Imaging')
  final ImagingSettings20? imaging;
  @JsonKey(name: 'Extension')
  final VideoSourceExtension2? extension_;
  VideoSourceExtension({
    this.imaging,
    this.extension_,
  });
}

class VideoSourceExtension2 {}

/// Representation of a physical audio input.
class AudioSource {}

///
/// A media profile consists of a set of media configurations. Media profiles are used by a client
/// to configure properties of a media stream from an NVT.
/// An NVT shall provide at least one media profile at boot. An NVT should provide “ready to use”
/// profiles for the most common media configurations that the device offers.
/// A profile consists of a set of interconnected configuration entities. Configurations are provided
/// by the NVT and can be either static or created dynamically by the NVT. For example, the
/// dynamic configurations can be created by the NVT depending on current available encoding
/// resources.
///
@JsonSerializable()
class Profile {
  /// User readable name of the profile.
  @JsonKey(name: 'Name')
  final String name;

  /// Optional configuration of the Video input.
  @JsonKey(name: 'VideoSourceConfiguration')
  final VideoSourceConfiguration? videoSourceConfiguration;

  /// Optional configuration of the Audio input.
  @JsonKey(name: 'AudioSourceConfiguration')
  final AudioSourceConfiguration? audioSourceConfiguration;

  /// Optional configuration of the Video encoder.
  @JsonKey(name: 'VideoEncoderConfiguration')
  final VideoEncoderConfiguration? videoEncoderConfiguration;

  /// Optional configuration of the Audio encoder.
  @JsonKey(name: 'AudioEncoderConfiguration')
  final AudioEncoderConfiguration? audioEncoderConfiguration;

  /// Optional configuration of the video analytics module and rule engine.
  @JsonKey(name: 'VideoAnalyticsConfiguration')
  final VideoAnalyticsConfiguration? videoAnalyticsConfiguration;

  /// Optional configuration of the pan tilt zoom unit.
  @JsonKey(name: 'PTZConfiguration')
  final PTZConfiguration? pTZConfiguration;

  /// Optional configuration of the metadata stream.
  @JsonKey(name: 'MetadataConfiguration')
  final MetadataConfiguration? metadataConfiguration;

  /// Extensions defined in ONVIF 2.0
  @JsonKey(name: 'Extension')
  final ProfileExtension? extension_;

  /// Unique identifier of the profile.
  @JsonKey(name: 'token')
  final ReferenceToken token;

  /// A value of true signals that the profile cannot be deleted. Default is false.
  @JsonKey(name: 'fixed')
  final bool fixed;
  Profile({
    required this.name,
    this.videoSourceConfiguration,
    this.audioSourceConfiguration,
    this.videoEncoderConfiguration,
    this.audioEncoderConfiguration,
    this.videoAnalyticsConfiguration,
    this.pTZConfiguration,
    this.metadataConfiguration,
    this.extension_,
    required this.token,
    required this.fixed,
  });
}

@JsonSerializable()
class ProfileExtension {
  /// Optional configuration of the Audio output.
  @JsonKey(name: 'AudioOutputConfiguration')
  final AudioOutputConfiguration? audioOutputConfiguration;

  /// Optional configuration of the Audio decoder.
  @JsonKey(name: 'AudioDecoderConfiguration')
  final AudioDecoderConfiguration? audioDecoderConfiguration;
  @JsonKey(name: 'Extension')
  final ProfileExtension2? extension_;
  ProfileExtension({
    this.audioOutputConfiguration,
    this.audioDecoderConfiguration,
    this.extension_,
  });
}

class ProfileExtension2 {}

/// Base type defining the common properties of a configuration.
@JsonSerializable()
class ConfigurationEntity {
  /// User readable name. Length up to 64 characters.
  @JsonKey(name: 'Name')
  final String name;

  /// Number of internal references currently using this configuration. This informational parameter is read-only. Deprecated for Media2 Service.
  @JsonKey(name: 'UseCount')
  final int useCount;

  /// Token that uniquely references this configuration. Length up to 64 characters.
  @JsonKey(name: 'token')
  final ReferenceToken token;
  ConfigurationEntity({
    required this.name,
    required this.useCount,
    required this.token,
  });
}

class VideoSourceConfiguration {}

@JsonSerializable()
class VideoSourceConfigurationExtension {
  /// Optional element to configure rotation of captured image.
  /// What resolutions a device supports shall be unaffected by the Rotate parameters.
  /// If a device is configured with Rotate=AUTO, the device shall take control over the Degree parameter and automatically update it so that a client can query current rotation.
  /// The device shall automatically apply the same rotation to its pan/tilt control direction depending on the following condition:
  /// if Reverse=AUTO in PTControlDirection or if the device doesn’t support Reverse in PTControlDirection
  ///
  @JsonKey(name: 'Rotate')
  final Rotate? rotate;
  @JsonKey(name: 'Extension')
  final VideoSourceConfigurationExtension2? extension_;
  VideoSourceConfigurationExtension({
    this.rotate,
    this.extension_,
  });
}

@JsonSerializable()
class VideoSourceConfigurationExtension2 {
  /// Optional element describing the geometric lens distortion. Multiple instances for future variable lens support.
  @JsonKey(name: 'LensDescription')
  final LensDescription? lensDescription;

  /// Optional element describing the scene orientation in the camera’s field of view.
  @JsonKey(name: 'SceneOrientation')
  final SceneOrientation? sceneOrientation;
  VideoSourceConfigurationExtension2({
    this.lensDescription,
    this.sceneOrientation,
  });
}

@JsonSerializable()
class Rotate {
  /// Parameter to enable/disable Rotation feature.
  @JsonKey(name: 'Mode')
  final RotateMode mode;

  /// Optional parameter to configure how much degree of clockwise rotation of image  for On mode. Omitting this parameter for On mode means 180 degree rotation.
  @JsonKey(name: 'Degree')
  final int? degree;
  @JsonKey(name: 'Extension')
  final RotateExtension? extension_;
  Rotate({
    required this.mode,
    this.degree,
    this.extension_,
  });
}

class RotateExtension {}

enum RotateMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("AUTO")
  AUTO,
}

@JsonSerializable()
class LensProjection {
  /// Angle of incidence.
  @JsonKey(name: 'Angle')
  final double angle;

  /// Mapping radius as a consequence of the emergent angle.
  @JsonKey(name: 'Radius')
  final double radius;

  /// Optional ray absorption at the given angle due to vignetting. A value of one means no absorption.
  @JsonKey(name: 'Transmittance')
  final double? transmittance;
  LensProjection({
    required this.angle,
    required this.radius,
    this.transmittance,
  });
}

@JsonSerializable()
class LensOffset {
  /// Optional horizontal offset of the lens center in normalized coordinates.
  @JsonKey(name: 'x')
  final double x;

  /// Optional vertical offset of the lens center in normalized coordinates.
  @JsonKey(name: 'y')
  final double y;
  LensOffset({
    required this.x,
    required this.y,
  });
}

@JsonSerializable()
class LensDescription {
  /// Offset of the lens center to the imager center in normalized coordinates.
  @JsonKey(name: 'Offset')
  final LensOffset offset;

  /// Radial description of the projection characteristics. The resulting curve is defined by the B-Spline interpolation
  /// over the given elements. The element for Radius zero shall not be provided. The projection points shall be ordered with ascending Radius.
  /// Items outside the last projection Radius shall be assumed to be invisible (black).
  @JsonKey(name: 'Projection')
  final LensProjection projection;

  /// Compensation of the x coordinate needed for the ONVIF normalized coordinate system.
  @JsonKey(name: 'XFactor')
  final double xFactor;

  /// Optional focal length of the optical system.
  @JsonKey(name: 'FocalLength')
  final double focalLength;
  LensDescription({
    required this.offset,
    required this.projection,
    required this.xFactor,
    required this.focalLength,
  });
}

@JsonSerializable()
class VideoSourceConfigurationOptions {
  ///
  /// Supported range for the capturing area.
  /// Device that does not support cropped streaming shall express BoundsRange option as mentioned below
  /// BoundsRange->XRange and BoundsRange->YRange with same Min/Max values HeightRange and WidthRange Min/Max values same as VideoSource Height and Width Limits.
  ///
  @JsonKey(name: 'BoundsRange')
  final IntRectangleRange boundsRange;

  /// List of physical inputs.
  @JsonKey(name: 'VideoSourceTokensAvailable')
  final ReferenceToken videoSourceTokensAvailable;
  @JsonKey(name: 'Extension')
  final VideoSourceConfigurationOptionsExtension? extension_;

  /// Maximum number of profiles.
  @JsonKey(name: 'MaximumNumberOfProfiles')
  final int maximumNumberOfProfiles;
  VideoSourceConfigurationOptions({
    required this.boundsRange,
    required this.videoSourceTokensAvailable,
    this.extension_,
    required this.maximumNumberOfProfiles,
  });
}

@JsonSerializable()
class VideoSourceConfigurationOptionsExtension {
  /// Options of parameters for Rotation feature.
  @JsonKey(name: 'Rotate')
  final RotateOptions? rotate;
  @JsonKey(name: 'Extension')
  final VideoSourceConfigurationOptionsExtension2? extension_;
  VideoSourceConfigurationOptionsExtension({
    this.rotate,
    this.extension_,
  });
}

@JsonSerializable()
class VideoSourceConfigurationOptionsExtension2 {
  /// Scene orientation modes supported by the device for this configuration.
  @JsonKey(name: 'SceneOrientationMode')
  final SceneOrientationMode? sceneOrientationMode;
  VideoSourceConfigurationOptionsExtension2({
    this.sceneOrientationMode,
  });
}

@JsonSerializable()
class RotateOptions {
  /// Supported options of Rotate mode parameter.
  @JsonKey(name: 'Mode')
  final RotateMode mode;

  /// List of supported degree value for rotation.
  @JsonKey(name: 'DegreeList')
  final IntList? degreeList;
  @JsonKey(name: 'Extension')
  final RotateOptionsExtension? extension_;

  /// After setting the rotation, if a device starts to reboot this value is true.
  /// If a device can handle rotation setting without rebooting this value is false.
  @JsonKey(name: 'Reboot')
  final bool reboot;
  RotateOptions({
    required this.mode,
    this.degreeList,
    this.extension_,
    required this.reboot,
  });
}

class RotateOptionsExtension {}

enum SceneOrientationMode {
  @JsonValue("MANUAL")
  MANUAL,
  @JsonValue("AUTO")
  AUTO,
}

enum SceneOrientationOption {
  @JsonValue("Below")
  Below,
  @JsonValue("Horizon")
  Horizon,
  @JsonValue("Above")
  Above,
}

@JsonSerializable()
class SceneOrientation {
  ///
  /// Parameter to assign the way the camera determines the scene orientation.
  ///
  @JsonKey(name: 'Mode')
  final SceneOrientationMode mode;

  ///
  /// Assigned or determined scene orientation based on the Mode. When assigning the Mode to AUTO, this field
  /// is optional and will be ignored by the device. When assigning the Mode to MANUAL, this field is required
  /// and the device will return an InvalidArgs fault if missing.
  ///
  @JsonKey(name: 'Orientation')
  final String? orientation;
  SceneOrientation({
    required this.mode,
    this.orientation,
  });
}

/// Source view modes supported by device.
enum ViewModes {
  @JsonValue("tt:Fisheye")
  Fisheye,
  @JsonValue("tt:360Panorama")
  _360Panorama,
  @JsonValue("tt:180Panorama")
  _180Panorama,
  @JsonValue("tt:Quad")
  Quad,
  @JsonValue("tt:Original")
  Original,
  @JsonValue("tt:LeftHalf")
  LeftHalf,
  @JsonValue("tt:RightHalf")
  RightHalf,
  @JsonValue("tt:Dewarp")
  Dewarp,
}

class VideoEncoderConfiguration {}

enum VideoEncoding {
  @JsonValue("JPEG")
  JPEG,
  @JsonValue("MPEG4")
  MPEG4,
  @JsonValue("H264")
  H264,
}

enum Mpeg4Profile {
  @JsonValue("SP")
  SP,
  @JsonValue("ASP")
  ASP,
}

enum H264Profile {
  @JsonValue("Baseline")
  Baseline,
  @JsonValue("Main")
  Main,
  @JsonValue("Extended")
  Extended,
  @JsonValue("High")
  High,
}

@JsonSerializable()
class VideoResolution {
  /// Number of the columns of the Video image.
  @JsonKey(name: 'Width')
  final int width;

  /// Number of the lines of the Video image.
  @JsonKey(name: 'Height')
  final int height;
  VideoResolution({
    required this.width,
    required this.height,
  });
}

@JsonSerializable()
class VideoRateControl {
  /// Maximum output framerate in fps. If an EncodingInterval is provided the resulting encoded framerate will be reduced by the given factor.
  @JsonKey(name: 'FrameRateLimit')
  final int frameRateLimit;

  /// Interval at which images are encoded and transmitted. (A value of 1 means that every frame is encoded, a value of 2 means that every 2nd frame is encoded ...)
  @JsonKey(name: 'EncodingInterval')
  final int encodingInterval;

  /// the maximum output bitrate in kbps
  @JsonKey(name: 'BitrateLimit')
  final int bitrateLimit;
  VideoRateControl({
    required this.frameRateLimit,
    required this.encodingInterval,
    required this.bitrateLimit,
  });
}

@JsonSerializable()
class Mpeg4Configuration {
  /// Determines the interval in which the I-Frames will be coded. An entry of 1 indicates I-Frames are continuously generated. An entry of 2 indicates that every 2nd image is an I-Frame, and 3 only every 3rd frame, etc. The frames in between are coded as P or B Frames.
  @JsonKey(name: 'GovLength')
  final int govLength;

  /// the Mpeg4 profile, either simple profile (SP) or advanced simple profile (ASP)
  @JsonKey(name: 'Mpeg4Profile')
  final Mpeg4Profile mpeg4Profile;
  Mpeg4Configuration({
    required this.govLength,
    required this.mpeg4Profile,
  });
}

@JsonSerializable()
class H264Configuration {
  /// Group of Video frames length. Determines typically the interval in which the I-Frames will be coded. An entry of 1 indicates I-Frames are continuously generated. An entry of 2 indicates that every 2nd image is an I-Frame, and 3 only every 3rd frame, etc. The frames in between are coded as P or B Frames.
  @JsonKey(name: 'GovLength')
  final int govLength;

  /// the H.264 profile, either baseline, main, extended or high
  @JsonKey(name: 'H264Profile')
  final H264Profile h264Profile;
  H264Configuration({
    required this.govLength,
    required this.h264Profile,
  });
}

@JsonSerializable()
class VideoEncoderConfigurationOptions {
  /// Range of the quality values. A high value means higher quality.
  @JsonKey(name: 'QualityRange')
  final IntRange qualityRange;

  /// Optional JPEG encoder settings ranges (See also Extension element).
  @JsonKey(name: 'JPEG')
  final JpegOptions? jPEG;

  /// Optional MPEG-4 encoder settings ranges (See also Extension element).
  @JsonKey(name: 'MPEG4')
  final Mpeg4Options? mPEG4;

  /// Optional H.264 encoder settings ranges (See also Extension element).
  @JsonKey(name: 'H264')
  final H264Options? h264;
  @JsonKey(name: 'Extension')
  final VideoEncoderOptionsExtension? extension_;

  ///
  /// Indicates the support for the GuaranteedFrameRate attribute on the VideoEncoderConfiguration element.
  ///
  @JsonKey(name: 'GuaranteedFrameRateSupported')
  final bool guaranteedFrameRateSupported;
  VideoEncoderConfigurationOptions({
    required this.qualityRange,
    this.jPEG,
    this.mPEG4,
    this.h264,
    this.extension_,
    required this.guaranteedFrameRateSupported,
  });
}

@JsonSerializable()
class VideoEncoderOptionsExtension {
  /// Optional JPEG encoder settings ranges.
  @JsonKey(name: 'JPEG')
  final JpegOptions2? jPEG;

  /// Optional MPEG-4 encoder settings ranges.
  @JsonKey(name: 'MPEG4')
  final Mpeg4Options2? mPEG4;

  /// Optional H.264 encoder settings ranges.
  @JsonKey(name: 'H264')
  final H264Options2? h264;
  @JsonKey(name: 'Extension')
  final VideoEncoderOptionsExtension2? extension_;
  VideoEncoderOptionsExtension({
    this.jPEG,
    this.mPEG4,
    this.h264,
    this.extension_,
  });
}

class VideoEncoderOptionsExtension2 {}

@JsonSerializable()
class JpegOptions {
  /// List of supported image sizes.
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// Supported frame rate in fps (frames per second).
  @JsonKey(name: 'FrameRateRange')
  final IntRange frameRateRange;

  /// Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.
  @JsonKey(name: 'EncodingIntervalRange')
  final IntRange encodingIntervalRange;
  JpegOptions({
    required this.resolutionsAvailable,
    required this.frameRateRange,
    required this.encodingIntervalRange,
  });
}

class JpegOptions2 {}

@JsonSerializable()
class Mpeg4Options {
  /// List of supported image sizes.
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// Supported group of Video frames length. This value typically corresponds to the I-Frame distance.
  @JsonKey(name: 'GovLengthRange')
  final IntRange govLengthRange;

  /// Supported frame rate in fps (frames per second).
  @JsonKey(name: 'FrameRateRange')
  final IntRange frameRateRange;

  /// Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.
  @JsonKey(name: 'EncodingIntervalRange')
  final IntRange encodingIntervalRange;

  /// List of supported MPEG-4 profiles.
  @JsonKey(name: 'Mpeg4ProfilesSupported')
  final Mpeg4Profile mpeg4ProfilesSupported;
  Mpeg4Options({
    required this.resolutionsAvailable,
    required this.govLengthRange,
    required this.frameRateRange,
    required this.encodingIntervalRange,
    required this.mpeg4ProfilesSupported,
  });
}

class Mpeg4Options2 {}

@JsonSerializable()
class H264Options {
  /// List of supported image sizes.
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// Supported group of Video frames length. This value typically corresponds to the I-Frame distance.
  @JsonKey(name: 'GovLengthRange')
  final IntRange govLengthRange;

  /// Supported frame rate in fps (frames per second).
  @JsonKey(name: 'FrameRateRange')
  final IntRange frameRateRange;

  /// Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.
  @JsonKey(name: 'EncodingIntervalRange')
  final IntRange encodingIntervalRange;

  /// List of supported H.264 profiles.
  @JsonKey(name: 'H264ProfilesSupported')
  final H264Profile h264ProfilesSupported;
  H264Options({
    required this.resolutionsAvailable,
    required this.govLengthRange,
    required this.frameRateRange,
    required this.encodingIntervalRange,
    required this.h264ProfilesSupported,
  });
}

class H264Options2 {}

/// Video Media Subtypes as referenced by IANA (without the leading "video/" Video Media Type).  See also  IANA Media Types.
enum VideoEncodingMimeNames {
  @JsonValue("JPEG")
  JPEG,
  @JsonValue("MPV4-ES")
  MPV4_ES,
  @JsonValue("H264")
  H264,
  @JsonValue("H265")
  H265,
}

enum VideoEncodingProfiles {
  @JsonValue("Simple")
  Simple,
  @JsonValue("AdvancedSimple")
  AdvancedSimple,
  @JsonValue("Baseline")
  Baseline,
  @JsonValue("Main")
  Main,
  @JsonValue("Main10")
  Main10,
  @JsonValue("Extended")
  Extended,
  @JsonValue("High")
  High,
}

class VideoEncoder2Configuration {}

@JsonSerializable()
class VideoResolution2 {
  /// Number of the columns of the Video image.
  @JsonKey(name: 'Width')
  final int width;

  /// Number of the lines of the Video image.
  @JsonKey(name: 'Height')
  final int height;
  VideoResolution2({
    required this.width,
    required this.height,
  });
}

@JsonSerializable()
class VideoRateControl2 {
  /// Desired frame rate in fps. The actual rate may be lower due to e.g. performance limitations.
  @JsonKey(name: 'FrameRateLimit')
  final double frameRateLimit;

  /// the maximum output bitrate in kbps
  @JsonKey(name: 'BitrateLimit')
  final int bitrateLimit;

  /// Enforce constant bitrate.
  @JsonKey(name: 'ConstantBitRate')
  final bool constantBitRate;
  VideoRateControl2({
    required this.frameRateLimit,
    required this.bitrateLimit,
    required this.constantBitRate,
  });
}

@JsonSerializable()
class VideoEncoder2ConfigurationOptions {
  /// Video Media Subtype for the video format. For definitions see tt:VideoEncodingMimeNames and  IANA Media Types.
  @JsonKey(name: 'Encoding')
  final String encoding;

  /// Range of the quality values. A high value means higher quality.
  @JsonKey(name: 'QualityRange')
  final FloatRange qualityRange;

  /// List of supported image sizes.
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution2 resolutionsAvailable;

  /// Supported range of encoded bitrate in kbps.
  @JsonKey(name: 'BitrateRange')
  final IntRange bitrateRange;

  /// Exactly two values, which define the Lower and Upper bounds for the supported group of Video frames length. These values typically correspond to the I-Frame distance.
  @JsonKey(name: 'GovLengthRange')
  final IntAttrList govLengthRange;

  /// List of supported target frame rates in fps (frames per second). The list shall be sorted with highest values first.
  @JsonKey(name: 'FrameRatesSupported')
  final FloatAttrList frameRatesSupported;

  /// List of supported encoder profiles as defined in tt::VideoEncodingProfiles.
  @JsonKey(name: 'ProfilesSupported')
  final StringAttrList profilesSupported;

  /// Signal whether enforcing constant bitrate is supported.
  @JsonKey(name: 'ConstantBitRateSupported')
  final bool constantBitRateSupported;

  ///
  /// Indicates the support for the GuaranteedFrameRate attribute on the VideoEncoder2Configuration element.
  ///
  @JsonKey(name: 'GuaranteedFrameRateSupported')
  final bool guaranteedFrameRateSupported;
  VideoEncoder2ConfigurationOptions({
    required this.encoding,
    required this.qualityRange,
    required this.resolutionsAvailable,
    required this.bitrateRange,
    required this.govLengthRange,
    required this.frameRatesSupported,
    required this.profilesSupported,
    required this.constantBitRateSupported,
    required this.guaranteedFrameRateSupported,
  });
}

class AudioSourceConfiguration {}

@JsonSerializable()
class AudioSourceConfigurationOptions {
  /// Tokens of the audio source the configuration can be used for.
  @JsonKey(name: 'InputTokensAvailable')
  final ReferenceToken inputTokensAvailable;
  @JsonKey(name: 'Extension')
  final AudioSourceOptionsExtension? extension_;
  AudioSourceConfigurationOptions({
    required this.inputTokensAvailable,
    this.extension_,
  });
}

class AudioSourceOptionsExtension {}

class AudioEncoderConfiguration {}

enum AudioEncoding {
  @JsonValue("G711")
  G711,
  @JsonValue("G726")
  G726,
  @JsonValue("AAC")
  AAC,
}

@JsonSerializable()
class AudioEncoderConfigurationOptions {
  /// list of supported AudioEncoderConfigurations
  @JsonKey(name: 'Options')
  final AudioEncoderConfigurationOption? options;
  AudioEncoderConfigurationOptions({
    this.options,
  });
}

@JsonSerializable()
class AudioEncoderConfigurationOption {
  /// The enoding used for audio data (either G.711, G.726 or AAC)
  @JsonKey(name: 'Encoding')
  final AudioEncoding encoding;

  /// List of supported bitrates in kbps for the specified Encoding
  @JsonKey(name: 'BitrateList')
  final IntList bitrateList;

  /// List of supported Sample Rates in kHz for the specified Encoding
  @JsonKey(name: 'SampleRateList')
  final IntList sampleRateList;
  AudioEncoderConfigurationOption({
    required this.encoding,
    required this.bitrateList,
    required this.sampleRateList,
  });
}

/// Audio Media Subtypes as referenced by IANA (without the leading "audio/" Audio Media Type).  See also  IANA Media Types.
enum AudioEncodingMimeNames {
  @JsonValue("PCMU")
  PCMU,
  @JsonValue("G726")
  G726,
  @JsonValue("MP4A-LATM")
  MP4A_LATM,
  @JsonValue("mpeg4-generic")
  mpeg4_generic,
}

class AudioEncoder2Configuration {}

@JsonSerializable()
class AudioEncoder2ConfigurationOptions {
  /// Audio Media Subtype for the audio format. For definitions see tt:AudioEncodingMimeNames and  IANA Media Types.
  @JsonKey(name: 'Encoding')
  final String encoding;

  /// List of supported bitrates in kbps for the specified Encoding
  @JsonKey(name: 'BitrateList')
  final IntList bitrateList;

  /// List of supported Sample Rates in kHz for the specified Encoding
  @JsonKey(name: 'SampleRateList')
  final IntList sampleRateList;
  AudioEncoder2ConfigurationOptions({
    required this.encoding,
    required this.bitrateList,
    required this.sampleRateList,
  });
}

class VideoAnalyticsConfiguration {}

class MetadataConfiguration {}

class MetadataConfigurationExtension {}

@JsonSerializable()
class PTZFilter {
  /// True if the metadata stream shall contain the PTZ status (IDLE, MOVING or UNKNOWN)
  @JsonKey(name: 'Status')
  final bool status;

  /// True if the metadata stream shall contain the PTZ position
  @JsonKey(name: 'Position')
  final bool position;
  PTZFilter({
    required this.status,
    required this.position,
  });
}

/// Subcription handling in the same way as base notification subscription.
@JsonSerializable()
class EventSubscription {
  @JsonKey(name: 'Filter')
  final FilterType? filter;
  EventSubscription({
    this.filter,
  });
}

@JsonSerializable()
class MetadataConfigurationOptions {
  @JsonKey(name: 'PTZStatusFilterOptions')
  final PTZStatusFilterOptions pTZStatusFilterOptions;
  @JsonKey(name: 'Extension')
  final MetadataConfigurationOptionsExtension? extension_;

  /// True if the device is able to stream the Geo Located positions of each target.
  @JsonKey(name: 'GeoLocation')
  final bool geoLocation;
  MetadataConfigurationOptions({
    required this.pTZStatusFilterOptions,
    this.extension_,
    required this.geoLocation,
  });
}

@JsonSerializable()
class MetadataConfigurationOptionsExtension {
  /// List of supported metadata compression type. Its options shall be chosen from tt:MetadataCompressionType.
  @JsonKey(name: 'CompressionType')
  final String? compressionType;
  @JsonKey(name: 'Extension')
  final MetadataConfigurationOptionsExtension2? extension_;
  MetadataConfigurationOptionsExtension({
    this.compressionType,
    this.extension_,
  });
}

class MetadataConfigurationOptionsExtension2 {}

enum MetadataCompressionType {
  @JsonValue("None")
  None,
  @JsonValue("GZIP")
  GZIP,
  @JsonValue("EXI")
  EXI,
}

@JsonSerializable()
class PTZStatusFilterOptions {
  /// True if the device is able to stream pan or tilt status information.
  @JsonKey(name: 'PanTiltStatusSupported')
  final bool panTiltStatusSupported;

  /// True if the device is able to stream zoom status inforamtion.
  @JsonKey(name: 'ZoomStatusSupported')
  final bool zoomStatusSupported;

  /// True if the device is able to stream the pan or tilt position.
  @JsonKey(name: 'PanTiltPositionSupported')
  final bool? panTiltPositionSupported;

  /// True if the device is able to stream zoom position information.
  @JsonKey(name: 'ZoomPositionSupported')
  final bool? zoomPositionSupported;
  @JsonKey(name: 'Extension')
  final PTZStatusFilterOptionsExtension? extension_;
  PTZStatusFilterOptions({
    required this.panTiltStatusSupported,
    required this.zoomStatusSupported,
    this.panTiltPositionSupported,
    this.zoomPositionSupported,
    this.extension_,
  });
}

class PTZStatusFilterOptionsExtension {}

/// Representation of a physical video outputs.
class VideoOutput {}

class VideoOutputExtension {}

class VideoOutputConfiguration {}

class VideoOutputConfigurationOptions {}

@JsonSerializable()
class VideoDecoderConfigurationOptions {
  /// If the device is able to decode Jpeg streams this element describes the supported codecs and configurations
  @JsonKey(name: 'JpegDecOptions')
  final JpegDecOptions? jpegDecOptions;

  /// If the device is able to decode H.264 streams this element describes the supported codecs and configurations
  @JsonKey(name: 'H264DecOptions')
  final H264DecOptions? h264DecOptions;

  /// If the device is able to decode Mpeg4 streams this element describes the supported codecs and configurations
  @JsonKey(name: 'Mpeg4DecOptions')
  final Mpeg4DecOptions? mpeg4DecOptions;
  @JsonKey(name: 'Extension')
  final VideoDecoderConfigurationOptionsExtension? extension_;
  VideoDecoderConfigurationOptions({
    this.jpegDecOptions,
    this.h264DecOptions,
    this.mpeg4DecOptions,
    this.extension_,
  });
}

@JsonSerializable()
class H264DecOptions {
  /// List of supported H.264 Video Resolutions
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// List of supported H264 Profiles (either baseline, main, extended or high)
  @JsonKey(name: 'SupportedH264Profiles')
  final H264Profile supportedH264Profiles;

  /// Supported H.264 bitrate range in kbps
  @JsonKey(name: 'SupportedInputBitrate')
  final IntRange supportedInputBitrate;

  /// Supported H.264 framerate range in fps
  @JsonKey(name: 'SupportedFrameRate')
  final IntRange supportedFrameRate;
  H264DecOptions({
    required this.resolutionsAvailable,
    required this.supportedH264Profiles,
    required this.supportedInputBitrate,
    required this.supportedFrameRate,
  });
}

@JsonSerializable()
class JpegDecOptions {
  /// List of supported Jpeg Video Resolutions
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// Supported Jpeg bitrate range in kbps
  @JsonKey(name: 'SupportedInputBitrate')
  final IntRange supportedInputBitrate;

  /// Supported Jpeg framerate range in fps
  @JsonKey(name: 'SupportedFrameRate')
  final IntRange supportedFrameRate;
  JpegDecOptions({
    required this.resolutionsAvailable,
    required this.supportedInputBitrate,
    required this.supportedFrameRate,
  });
}

@JsonSerializable()
class Mpeg4DecOptions {
  /// List of supported Mpeg4 Video Resolutions
  @JsonKey(name: 'ResolutionsAvailable')
  final VideoResolution resolutionsAvailable;

  /// List of supported Mpeg4 Profiles (either SP or ASP)
  @JsonKey(name: 'SupportedMpeg4Profiles')
  final Mpeg4Profile supportedMpeg4Profiles;

  /// Supported Mpeg4 bitrate range in kbps
  @JsonKey(name: 'SupportedInputBitrate')
  final IntRange supportedInputBitrate;

  /// Supported Mpeg4 framerate range in fps
  @JsonKey(name: 'SupportedFrameRate')
  final IntRange supportedFrameRate;
  Mpeg4DecOptions({
    required this.resolutionsAvailable,
    required this.supportedMpeg4Profiles,
    required this.supportedInputBitrate,
    required this.supportedFrameRate,
  });
}

class VideoDecoderConfigurationOptionsExtension {}

/// Representation of a physical audio outputs.
class AudioOutput {}

class AudioOutputConfiguration {}

@JsonSerializable()
class AudioOutputConfigurationOptions {
  /// Tokens of the physical Audio outputs (typically one).
  @JsonKey(name: 'OutputTokensAvailable')
  final ReferenceToken outputTokensAvailable;

  ///
  /// An audio channel MAY support different types of audio transmission. While for full duplex
  /// operation no special handling is required, in half duplex operation the transmission direction
  /// needs to be switched.
  /// The optional SendPrimacy parameter inside the AudioOutputConfiguration indicates which
  /// direction is currently active. An NVC can switch between different modes by setting the
  /// AudioOutputConfiguration.
  /// The following modes for the Send-Primacy are defined:
  /// www.onvif.org/ver20/HalfDuplex/Server
  /// The server is allowed to send audio data to the client. The client shall not send
  /// audio data via the backchannel to the NVT in this mode.
  /// www.onvif.org/ver20/HalfDuplex/Client
  /// The client is allowed to send audio data via the backchannel to the server. The
  /// NVT shall not send audio data to the client in this mode.
  /// www.onvif.org/ver20/HalfDuplex/Auto
  /// It is up to the device how to deal with sending and receiving audio data.
  ///
  /// Acoustic echo cancellation is out of ONVIF scope.
  @JsonKey(name: 'SendPrimacyOptions')
  final String? sendPrimacyOptions;

  /// Minimum and maximum level range supported for this Output.
  @JsonKey(name: 'OutputLevelRange')
  final IntRange outputLevelRange;
  AudioOutputConfigurationOptions({
    required this.outputTokensAvailable,
    this.sendPrimacyOptions,
    required this.outputLevelRange,
  });
}

/// The Audio Decoder Configuration does not contain any that parameter to configure the
/// decoding .A decoder shall decode every data it receives (according to its capabilities).
class AudioDecoderConfiguration {}

@JsonSerializable()
class AudioDecoderConfigurationOptions {
  /// If the device is able to decode AAC encoded audio this section describes the supported configurations
  @JsonKey(name: 'AACDecOptions')
  final AACDecOptions? aACDecOptions;

  /// If the device is able to decode G711 encoded audio this section describes the supported configurations
  @JsonKey(name: 'G711DecOptions')
  final G711DecOptions? g711DecOptions;

  /// If the device is able to decode G726 encoded audio this section describes the supported configurations
  @JsonKey(name: 'G726DecOptions')
  final G726DecOptions? g726DecOptions;
  @JsonKey(name: 'Extension')
  final AudioDecoderConfigurationOptionsExtension? extension_;
  AudioDecoderConfigurationOptions({
    this.aACDecOptions,
    this.g711DecOptions,
    this.g726DecOptions,
    this.extension_,
  });
}

@JsonSerializable()
class G711DecOptions {
  /// List of supported bitrates in kbps
  @JsonKey(name: 'Bitrate')
  final IntList bitrate;

  /// List of supported sample rates in kHz
  @JsonKey(name: 'SampleRateRange')
  final IntList sampleRateRange;
  G711DecOptions({
    required this.bitrate,
    required this.sampleRateRange,
  });
}

@JsonSerializable()
class AACDecOptions {
  /// List of supported bitrates in kbps
  @JsonKey(name: 'Bitrate')
  final IntList bitrate;

  /// List of supported sample rates in kHz
  @JsonKey(name: 'SampleRateRange')
  final IntList sampleRateRange;
  AACDecOptions({
    required this.bitrate,
    required this.sampleRateRange,
  });
}

@JsonSerializable()
class G726DecOptions {
  /// List of supported bitrates in kbps
  @JsonKey(name: 'Bitrate')
  final IntList bitrate;

  /// List of supported sample rates in kHz
  @JsonKey(name: 'SampleRateRange')
  final IntList sampleRateRange;
  G726DecOptions({
    required this.bitrate,
    required this.sampleRateRange,
  });
}

class AudioDecoderConfigurationOptionsExtension {}

@JsonSerializable()
class MulticastConfiguration {
  /// The multicast address (if this address is set to 0 no multicast streaming is enaled)
  @JsonKey(name: 'Address')
  final IPAddress address;

  /// The RTP mutlicast destination port. A device may support RTCP. In this case the port value shall be even to allow the corresponding RTCP stream to be mapped to the next higher (odd) destination port number as defined in the RTSP specification.
  @JsonKey(name: 'Port')
  final int port;

  /// In case of IPv6 the TTL value is assumed as the hop limit. Note that for IPV6 and administratively scoped IPv4 multicast the primary use for hop limit / TTL is to prevent packets from (endlessly) circulating and not limiting scope. In these cases the address contains the scope.
  @JsonKey(name: 'TTL')
  final int tTL;

  /// Read only property signalling that streaming is persistant. Use the methods StartMulticastStreaming and StopMulticastStreaming to switch its state.
  @JsonKey(name: 'AutoStart')
  final bool autoStart;
  MulticastConfiguration({
    required this.address,
    required this.port,
    required this.tTL,
    required this.autoStart,
  });
}

@JsonSerializable()
class StreamSetup {
  /// Defines if a multicast or unicast stream is requested
  @JsonKey(name: 'Stream')
  final StreamType stream;
  @JsonKey(name: 'Transport')
  final Transport transport;
  StreamSetup({
    required this.stream,
    required this.transport,
  });
}

enum StreamType {
  @JsonValue("RTP-Unicast")
  RTP_Unicast,
  @JsonValue("RTP-Multicast")
  RTP_Multicast,
}

@JsonSerializable()
class Transport {
  /// Defines the network protocol for streaming, either UDP=RTP/UDP, RTSP=RTP/RTSP/TCP or HTTP=RTP/RTSP/HTTP/TCP
  @JsonKey(name: 'Protocol')
  final TransportProtocol protocol;

  /// Optional element to describe further tunnel options. This element is normally not needed
  @JsonKey(name: 'Tunnel')
  final Transport? tunnel;
  Transport({
    required this.protocol,
    this.tunnel,
  });
}

enum TransportProtocol {
  @JsonValue("UDP")
  UDP,
  @JsonValue("TCP")
  TCP,
  @JsonValue("RTSP")
  RTSP,
  @JsonValue("HTTP")
  HTTP,
}

@JsonSerializable()
class MediaUri {
  /// Stable Uri to be used for requesting the media stream
  @JsonKey(name: 'Uri')
  final String uri;

  /// Indicates if the Uri is only valid until the connection is established. The value shall be set to "false".
  @JsonKey(name: 'InvalidAfterConnect')
  final bool invalidAfterConnect;

  /// Indicates if the Uri is invalid after a reboot of the device. The value shall be set to "false".
  @JsonKey(name: 'InvalidAfterReboot')
  final bool invalidAfterReboot;

  /// Duration how long the Uri is valid. This parameter shall be set to PT0S to indicate that this stream URI is indefinitely valid even if the profile changes
  @JsonKey(name: 'Timeout')
  final Duration timeout;
  MediaUri({
    required this.uri,
    required this.invalidAfterConnect,
    required this.invalidAfterReboot,
    required this.timeout,
  });
}

enum ScopeDefinition {
  @JsonValue("Fixed")
  Fixed,
  @JsonValue("Configurable")
  Configurable,
}

@JsonSerializable()
class Scope {
  /// Indicates if the scope is fixed or configurable.
  @JsonKey(name: 'ScopeDef')
  final ScopeDefinition scopeDef;

  /// Scope item URI.
  @JsonKey(name: 'ScopeItem')
  final String scopeItem;
  Scope({
    required this.scopeDef,
    required this.scopeItem,
  });
}

enum DiscoveryMode {
  @JsonValue("Discoverable")
  Discoverable,
  @JsonValue("NonDiscoverable")
  NonDiscoverable,
}

class NetworkInterface {}

@JsonSerializable()
class NetworkInterfaceExtension {
  @JsonKey(name: 'InterfaceType')
  final IANA_IfTypes interfaceType;

  /// Extension point prepared for future 802.3 configuration.
  @JsonKey(name: 'Dot3')
  final Dot3Configuration? dot3;
  @JsonKey(name: 'Dot11')
  final Dot11Configuration? dot11;
  @JsonKey(name: 'Extension')
  final NetworkInterfaceExtension2? extension_;
  NetworkInterfaceExtension({
    required this.interfaceType,
    this.dot3,
    this.dot11,
    this.extension_,
  });
}

@JsonSerializable()
class NetworkInterfaceConfigPriority {
  @JsonKey(name: 'val')
  final int val;
  NetworkInterfaceConfigPriority({
    required this.val,
  });
}

class Dot3Configuration {}

class NetworkInterfaceExtension2 {}

@JsonSerializable()
class NetworkInterfaceLink {
  /// Configured link settings.
  @JsonKey(name: 'AdminSettings')
  final NetworkInterfaceConnectionSetting adminSettings;

  /// Current active link settings.
  @JsonKey(name: 'OperSettings')
  final NetworkInterfaceConnectionSetting operSettings;

  /// Integer indicating interface type, for example: 6 is ethernet.
  @JsonKey(name: 'InterfaceType')
  final IANA_IfTypes interfaceType;
  NetworkInterfaceLink({
    required this.adminSettings,
    required this.operSettings,
    required this.interfaceType,
  });
}

@JsonSerializable()
class NetworkInterfaceConnectionSetting {
  /// Auto negotiation on/off.
  @JsonKey(name: 'AutoNegotiation')
  final bool autoNegotiation;

  /// Speed.
  @JsonKey(name: 'Speed')
  final int speed;

  /// Duplex type, Half or Full.
  @JsonKey(name: 'Duplex')
  final Duplex duplex;
  NetworkInterfaceConnectionSetting({
    required this.autoNegotiation,
    required this.speed,
    required this.duplex,
  });
}

enum Duplex {
  @JsonValue("Full")
  Full,
  @JsonValue("Half")
  Half,
}

@JsonSerializable()
class IANA_IfTypes {
  @JsonKey(name: 'val')
  final int val;
  IANA_IfTypes({
    required this.val,
  });
}

@JsonSerializable()
class NetworkInterfaceInfo {
  /// Network interface name, for example eth0.
  @JsonKey(name: 'Name')
  final String? name;

  /// Network interface MAC address.
  @JsonKey(name: 'HwAddress')
  final HwAddress hwAddress;

  /// Maximum transmission unit.
  @JsonKey(name: 'MTU')
  final int? mTU;
  NetworkInterfaceInfo({
    this.name,
    required this.hwAddress,
    this.mTU,
  });
}

@JsonSerializable()
class IPv6NetworkInterface {
  /// Indicates whether or not IPv6 is enabled.
  @JsonKey(name: 'Enabled')
  final bool enabled;

  /// IPv6 configuration.
  @JsonKey(name: 'Config')
  final IPv6Configuration? config;
  IPv6NetworkInterface({
    required this.enabled,
    this.config,
  });
}

@JsonSerializable()
class IPv4NetworkInterface {
  /// Indicates whether or not IPv4 is enabled.
  @JsonKey(name: 'Enabled')
  final bool enabled;

  /// IPv4 configuration.
  @JsonKey(name: 'Config')
  final IPv4Configuration config;
  IPv4NetworkInterface({
    required this.enabled,
    required this.config,
  });
}

@JsonSerializable()
class IPv4Configuration {
  /// List of manually added IPv4 addresses.
  @JsonKey(name: 'Manual')
  final PrefixedIPv4Address? manual;

  /// Link local address.
  @JsonKey(name: 'LinkLocal')
  final PrefixedIPv4Address? linkLocal;

  /// IPv4 address configured by using DHCP.
  @JsonKey(name: 'FromDHCP')
  final PrefixedIPv4Address? fromDHCP;

  /// Indicates whether or not DHCP is used.
  @JsonKey(name: 'DHCP')
  final bool dHCP;
  IPv4Configuration({
    this.manual,
    this.linkLocal,
    this.fromDHCP,
    required this.dHCP,
  });
}

@JsonSerializable()
class IPv6Configuration {
  /// Indicates whether router advertisment is used.
  @JsonKey(name: 'AcceptRouterAdvert')
  final bool? acceptRouterAdvert;

  /// DHCP configuration.
  @JsonKey(name: 'DHCP')
  final IPv6DHCPConfiguration dHCP;

  /// List of manually entered IPv6 addresses.
  @JsonKey(name: 'Manual')
  final PrefixedIPv6Address? manual;

  /// List of link local IPv6 addresses.
  @JsonKey(name: 'LinkLocal')
  final PrefixedIPv6Address? linkLocal;

  /// List of IPv6 addresses configured by using DHCP.
  @JsonKey(name: 'FromDHCP')
  final PrefixedIPv6Address? fromDHCP;

  /// List of IPv6 addresses configured by using router advertisment.
  @JsonKey(name: 'FromRA')
  final PrefixedIPv6Address? fromRA;
  @JsonKey(name: 'Extension')
  final IPv6ConfigurationExtension? extension_;
  IPv6Configuration({
    this.acceptRouterAdvert,
    required this.dHCP,
    this.manual,
    this.linkLocal,
    this.fromDHCP,
    this.fromRA,
    this.extension_,
  });
}

class IPv6ConfigurationExtension {}

enum IPv6DHCPConfiguration {
  @JsonValue("Auto")
  Auto,
  @JsonValue("Stateful")
  Stateful,
  @JsonValue("Stateless")
  Stateless,
  @JsonValue("Off")
  Off,
}

@JsonSerializable()
class NetworkProtocol {
  /// Network protocol type string.
  @JsonKey(name: 'Name')
  final NetworkProtocolType name;

  /// Indicates if the protocol is enabled or not.
  @JsonKey(name: 'Enabled')
  final bool enabled;

  /// The port that is used by the protocol.
  @JsonKey(name: 'Port')
  final int port;
  @JsonKey(name: 'Extension')
  final NetworkProtocolExtension? extension_;
  NetworkProtocol({
    required this.name,
    required this.enabled,
    required this.port,
    this.extension_,
  });
}

class NetworkProtocolExtension {}

enum NetworkProtocolType {
  @JsonValue("HTTP")
  HTTP,
  @JsonValue("HTTPS")
  HTTPS,
  @JsonValue("RTSP")
  RTSP,
}

enum NetworkHostType {
  @JsonValue("IPv4")
  IPv4,
  @JsonValue("IPv6")
  IPv6,
  @JsonValue("DNS")
  DNS,
}

@JsonSerializable()
class NetworkHost {
  /// Network host type: IPv4, IPv6 or DNS.
  @JsonKey(name: 'Type')
  final NetworkHostType type;

  /// IPv4 address.
  @JsonKey(name: 'IPv4Address')
  final IPv4Address? iPv4Address;

  /// IPv6 address.
  @JsonKey(name: 'IPv6Address')
  final IPv6Address? iPv6Address;

  /// DNS name.
  @JsonKey(name: 'DNSname')
  final DNSName? dNSname;
  @JsonKey(name: 'Extension')
  final NetworkHostExtension? extension_;
  NetworkHost({
    required this.type,
    this.iPv4Address,
    this.iPv6Address,
    this.dNSname,
    this.extension_,
  });
}

class NetworkHostExtension {}

@JsonSerializable()
class IPAddress {
  /// Indicates if the address is an IPv4 or IPv6 address.
  @JsonKey(name: 'Type')
  final IPType type;

  /// IPv4 address.
  @JsonKey(name: 'IPv4Address')
  final IPv4Address? iPv4Address;

  /// IPv6 address
  @JsonKey(name: 'IPv6Address')
  final IPv6Address? iPv6Address;
  IPAddress({
    required this.type,
    this.iPv4Address,
    this.iPv6Address,
  });
}

@JsonSerializable()
class PrefixedIPv4Address {
  /// IPv4 address
  @JsonKey(name: 'Address')
  final IPv4Address address;

  /// Prefix/submask length
  @JsonKey(name: 'PrefixLength')
  final int prefixLength;
  PrefixedIPv4Address({
    required this.address,
    required this.prefixLength,
  });
}

@JsonSerializable()
class IPv4Address {
  @JsonKey(name: 'val')
  final String val;
  IPv4Address({
    required this.val,
  });
}

@JsonSerializable()
class PrefixedIPv6Address {
  /// IPv6 address
  @JsonKey(name: 'Address')
  final IPv6Address address;

  /// Prefix/submask length
  @JsonKey(name: 'PrefixLength')
  final int prefixLength;
  PrefixedIPv6Address({
    required this.address,
    required this.prefixLength,
  });
}

@JsonSerializable()
class IPv6Address {
  @JsonKey(name: 'val')
  final String val;
  IPv6Address({
    required this.val,
  });
}

@JsonSerializable()
class HwAddress {
  @JsonKey(name: 'val')
  final String val;
  HwAddress({
    required this.val,
  });
}

enum IPType {
  @JsonValue("IPv4")
  IPv4,
  @JsonValue("IPv6")
  IPv6,
}

@JsonSerializable()
class DNSName {
  @JsonKey(name: 'val')
  final String val;
  DNSName({
    required this.val,
  });
}

@JsonSerializable()
class HostnameInformation {
  /// Indicates whether the hostname is obtained from DHCP or not.
  @JsonKey(name: 'FromDHCP')
  final bool fromDHCP;

  /// Indicates the hostname.
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Extension')
  final HostnameInformationExtension? extension_;
  HostnameInformation({
    required this.fromDHCP,
    this.name,
    this.extension_,
  });
}

class HostnameInformationExtension {}

@JsonSerializable()
class DNSInformation {
  /// Indicates whether or not DNS information is retrieved from DHCP.
  @JsonKey(name: 'FromDHCP')
  final bool fromDHCP;

  /// Search domain.
  @JsonKey(name: 'SearchDomain')
  final String? searchDomain;

  /// List of DNS addresses received from DHCP.
  @JsonKey(name: 'DNSFromDHCP')
  final IPAddress? dNSFromDHCP;

  /// List of manually entered DNS addresses.
  @JsonKey(name: 'DNSManual')
  final IPAddress? dNSManual;
  @JsonKey(name: 'Extension')
  final DNSInformationExtension? extension_;
  DNSInformation({
    required this.fromDHCP,
    this.searchDomain,
    this.dNSFromDHCP,
    this.dNSManual,
    this.extension_,
  });
}

class DNSInformationExtension {}

@JsonSerializable()
class NTPInformation {
  /// Indicates if NTP information is to be retrieved by using DHCP.
  @JsonKey(name: 'FromDHCP')
  final bool fromDHCP;

  /// List of NTP addresses retrieved by using DHCP.
  @JsonKey(name: 'NTPFromDHCP')
  final NetworkHost? nTPFromDHCP;

  /// List of manually entered NTP addresses.
  @JsonKey(name: 'NTPManual')
  final NetworkHost? nTPManual;
  @JsonKey(name: 'Extension')
  final NTPInformationExtension? extension_;
  NTPInformation({
    required this.fromDHCP,
    this.nTPFromDHCP,
    this.nTPManual,
    this.extension_,
  });
}

class NTPInformationExtension {}

@JsonSerializable()
class Domain {
  @JsonKey(name: 'val')
  final String val;
  Domain({
    required this.val,
  });
}

enum IPAddressFilterType {
  @JsonValue("Allow")
  Allow,
  @JsonValue("Deny")
  Deny,
}

@JsonSerializable()
class DynamicDNSInformation {
  /// Dynamic DNS type.
  @JsonKey(name: 'Type')
  final DynamicDNSType type;

  /// DNS name.
  @JsonKey(name: 'Name')
  final DNSName? name;

  /// Time to live.
  @JsonKey(name: 'TTL')
  final Duration? tTL;
  @JsonKey(name: 'Extension')
  final DynamicDNSInformationExtension? extension_;
  DynamicDNSInformation({
    required this.type,
    this.name,
    this.tTL,
    this.extension_,
  });
}

class DynamicDNSInformationExtension {}

enum DynamicDNSType {
  @JsonValue("NoUpdate")
  NoUpdate,
  @JsonValue("ClientUpdates")
  ClientUpdates,
  @JsonValue("ServerUpdates")
  ServerUpdates,
}

@JsonSerializable()
class NetworkInterfaceSetConfiguration {
  /// Indicates whether or not an interface is enabled.
  @JsonKey(name: 'Enabled')
  final bool? enabled;

  /// Link configuration.
  @JsonKey(name: 'Link')
  final NetworkInterfaceConnectionSetting? link;

  /// Maximum transmission unit.
  @JsonKey(name: 'MTU')
  final int? mTU;

  /// IPv4 network interface configuration.
  @JsonKey(name: 'IPv4')
  final IPv4NetworkInterfaceSetConfiguration? iPv4;

  /// IPv6 network interface configuration.
  @JsonKey(name: 'IPv6')
  final IPv6NetworkInterfaceSetConfiguration? iPv6;
  @JsonKey(name: 'Extension')
  final NetworkInterfaceSetConfigurationExtension? extension_;
  NetworkInterfaceSetConfiguration({
    this.enabled,
    this.link,
    this.mTU,
    this.iPv4,
    this.iPv6,
    this.extension_,
  });
}

@JsonSerializable()
class NetworkInterfaceSetConfigurationExtension {
  @JsonKey(name: 'Dot3')
  final Dot3Configuration? dot3;
  @JsonKey(name: 'Dot11')
  final Dot11Configuration? dot11;
  @JsonKey(name: 'Extension')
  final NetworkInterfaceSetConfigurationExtension2? extension_;
  NetworkInterfaceSetConfigurationExtension({
    this.dot3,
    this.dot11,
    this.extension_,
  });
}

@JsonSerializable()
class IPv6NetworkInterfaceSetConfiguration {
  /// Indicates whether or not IPv6 is enabled.
  @JsonKey(name: 'Enabled')
  final bool? enabled;

  /// Indicates whether router advertisment is used.
  @JsonKey(name: 'AcceptRouterAdvert')
  final bool? acceptRouterAdvert;

  /// List of manually added IPv6 addresses.
  @JsonKey(name: 'Manual')
  final PrefixedIPv6Address? manual;

  /// DHCP configuration.
  @JsonKey(name: 'DHCP')
  final IPv6DHCPConfiguration? dHCP;
  IPv6NetworkInterfaceSetConfiguration({
    this.enabled,
    this.acceptRouterAdvert,
    this.manual,
    this.dHCP,
  });
}

@JsonSerializable()
class IPv4NetworkInterfaceSetConfiguration {
  /// Indicates whether or not IPv4 is enabled.
  @JsonKey(name: 'Enabled')
  final bool? enabled;

  /// List of manually added IPv4 addresses.
  @JsonKey(name: 'Manual')
  final PrefixedIPv4Address? manual;

  /// Indicates whether or not DHCP is used.
  @JsonKey(name: 'DHCP')
  final bool? dHCP;
  IPv4NetworkInterfaceSetConfiguration({
    this.enabled,
    this.manual,
    this.dHCP,
  });
}

@JsonSerializable()
class NetworkGateway {
  /// IPv4 address string.
  @JsonKey(name: 'IPv4Address')
  final IPv4Address? iPv4Address;

  /// IPv6 address string.
  @JsonKey(name: 'IPv6Address')
  final IPv6Address? iPv6Address;
  NetworkGateway({
    this.iPv4Address,
    this.iPv6Address,
  });
}

@JsonSerializable()
class NetworkZeroConfiguration {
  /// Unique identifier of network interface.
  @JsonKey(name: 'InterfaceToken')
  final ReferenceToken interfaceToken;

  /// Indicates whether the zero-configuration is enabled or not.
  @JsonKey(name: 'Enabled')
  final bool enabled;

  /// The zero-configuration IPv4 address(es)
  @JsonKey(name: 'Addresses')
  final IPv4Address? addresses;
  @JsonKey(name: 'Extension')
  final NetworkZeroConfigurationExtension? extension_;
  NetworkZeroConfiguration({
    required this.interfaceToken,
    required this.enabled,
    this.addresses,
    this.extension_,
  });
}

@JsonSerializable()
class NetworkZeroConfigurationExtension {
  /// Optional array holding the configuration for the second and possibly further interfaces.
  @JsonKey(name: 'Additional')
  final NetworkZeroConfiguration? additional;
  @JsonKey(name: 'Extension')
  final NetworkZeroConfigurationExtension2? extension_;
  NetworkZeroConfigurationExtension({
    this.additional,
    this.extension_,
  });
}

class NetworkZeroConfigurationExtension2 {}

@JsonSerializable()
class IPAddressFilter {
  @JsonKey(name: 'Type')
  final IPAddressFilterType type;
  @JsonKey(name: 'IPv4Address')
  final PrefixedIPv4Address? iPv4Address;
  @JsonKey(name: 'IPv6Address')
  final PrefixedIPv6Address? iPv6Address;
  @JsonKey(name: 'Extension')
  final IPAddressFilterExtension? extension_;
  IPAddressFilter({
    required this.type,
    this.iPv4Address,
    this.iPv6Address,
    this.extension_,
  });
}

class IPAddressFilterExtension {}

@JsonSerializable()
class Dot11Configuration {
  @JsonKey(name: 'SSID')
  final Dot11SSIDType sSID;
  @JsonKey(name: 'Mode')
  final Dot11StationMode mode;
  @JsonKey(name: 'Alias')
  final String alias;
  @JsonKey(name: 'Priority')
  final NetworkInterfaceConfigPriority priority;
  @JsonKey(name: 'Security')
  final Dot11SecurityConfiguration security;
  Dot11Configuration({
    required this.sSID,
    required this.mode,
    required this.alias,
    required this.priority,
    required this.security,
  });
}

@JsonSerializable()
class Dot11SSIDType {
  @JsonKey(name: 'val')
  final Uint8List val;
  Dot11SSIDType({
    required this.val,
  });
}

enum Dot11StationMode {
  @JsonValue("Ad-hoc")
  Ad_hoc,
  @JsonValue("Infrastructure")
  Infrastructure,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class Dot11SecurityConfiguration {
  @JsonKey(name: 'Mode')
  final Dot11SecurityMode mode;
  @JsonKey(name: 'Algorithm')
  final Dot11Cipher? algorithm;
  @JsonKey(name: 'PSK')
  final Dot11PSKSet? pSK;
  @JsonKey(name: 'Dot1X')
  final ReferenceToken? dot1X;
  @JsonKey(name: 'Extension')
  final Dot11SecurityConfigurationExtension? extension_;
  Dot11SecurityConfiguration({
    required this.mode,
    this.algorithm,
    this.pSK,
    this.dot1X,
    this.extension_,
  });
}

class Dot11SecurityConfigurationExtension {}

enum Dot11SecurityMode {
  @JsonValue("None")
  None,
  @JsonValue("WEP")
  WEP,
  @JsonValue("PSK")
  PSK,
  @JsonValue("Dot1X")
  Dot1X,
  @JsonValue("Extended")
  Extended,
}

enum Dot11Cipher {
  @JsonValue("CCMP")
  CCMP,
  @JsonValue("TKIP")
  TKIP,
  @JsonValue("Any")
  Any,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class Dot11PSK {
  @JsonKey(name: 'val')
  final Uint8List val;
  Dot11PSK({
    required this.val,
  });
}

@JsonSerializable()
class Dot11PSKPassphrase {
  @JsonKey(name: 'val')
  final String val;
  Dot11PSKPassphrase({
    required this.val,
  });
}

@JsonSerializable()
class Dot11PSKSet {
  ///
  /// According to IEEE802.11-2007 H.4.1 the RSNA PSK consists of 256 bits, or 64 octets when represented in hex
  /// Either Key or Passphrase shall be given, if both are supplied Key shall be used by the device and Passphrase ignored.
  ///
  @JsonKey(name: 'Key')
  final Dot11PSK? key;

  ///
  /// According to IEEE802.11-2007 H.4.1 a pass-phrase is a sequence of between 8 and 63 ASCII-encoded characters and
  /// each character in the pass-phrase must have an encoding in the range of 32 to 126 (decimal),inclusive.
  /// If only Passpharse is supplied the Key shall be derived using the algorithm described in IEEE802.11-2007 section H.4
  ///
  @JsonKey(name: 'Passphrase')
  final Dot11PSKPassphrase? passphrase;
  @JsonKey(name: 'Extension')
  final Dot11PSKSetExtension? extension_;
  Dot11PSKSet({
    this.key,
    this.passphrase,
    this.extension_,
  });
}

class Dot11PSKSetExtension {}

class NetworkInterfaceSetConfigurationExtension2 {}

@JsonSerializable()
class Dot11Capabilities {
  @JsonKey(name: 'TKIP')
  final bool tKIP;
  @JsonKey(name: 'ScanAvailableNetworks')
  final bool scanAvailableNetworks;
  @JsonKey(name: 'MultipleConfiguration')
  final bool multipleConfiguration;
  @JsonKey(name: 'AdHocStationMode')
  final bool adHocStationMode;
  @JsonKey(name: 'WEP')
  final bool wEP;
  Dot11Capabilities({
    required this.tKIP,
    required this.scanAvailableNetworks,
    required this.multipleConfiguration,
    required this.adHocStationMode,
    required this.wEP,
  });
}

enum Dot11SignalStrength {
  @JsonValue("None")
  None,
  @JsonValue("Very Bad")
  Very_Bad,
  @JsonValue("Bad")
  Bad,
  @JsonValue("Good")
  Good,
  @JsonValue("Very Good")
  Very_Good,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class Dot11Status {
  @JsonKey(name: 'SSID')
  final Dot11SSIDType sSID;
  @JsonKey(name: 'BSSID')
  final String? bSSID;
  @JsonKey(name: 'PairCipher')
  final Dot11Cipher? pairCipher;
  @JsonKey(name: 'GroupCipher')
  final Dot11Cipher? groupCipher;
  @JsonKey(name: 'SignalStrength')
  final Dot11SignalStrength? signalStrength;
  @JsonKey(name: 'ActiveConfigAlias')
  final ReferenceToken activeConfigAlias;
  Dot11Status({
    required this.sSID,
    this.bSSID,
    this.pairCipher,
    this.groupCipher,
    this.signalStrength,
    required this.activeConfigAlias,
  });
}

enum Dot11AuthAndMangementSuite {
  @JsonValue("None")
  None,
  @JsonValue("Dot1X")
  Dot1X,
  @JsonValue("PSK")
  PSK,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class Dot11AvailableNetworks {
  @JsonKey(name: 'SSID')
  final Dot11SSIDType sSID;
  @JsonKey(name: 'BSSID')
  final String? bSSID;

  /// See IEEE802.11 7.3.2.25.2 for details.
  @JsonKey(name: 'AuthAndMangementSuite')
  final Dot11AuthAndMangementSuite? authAndMangementSuite;
  @JsonKey(name: 'PairCipher')
  final Dot11Cipher? pairCipher;
  @JsonKey(name: 'GroupCipher')
  final Dot11Cipher? groupCipher;
  @JsonKey(name: 'SignalStrength')
  final Dot11SignalStrength? signalStrength;
  @JsonKey(name: 'Extension')
  final Dot11AvailableNetworksExtension? extension_;
  Dot11AvailableNetworks({
    required this.sSID,
    this.bSSID,
    this.authAndMangementSuite,
    this.pairCipher,
    this.groupCipher,
    this.signalStrength,
    this.extension_,
  });
}

class Dot11AvailableNetworksExtension {}

enum CapabilityCategory {
  @JsonValue("All")
  All,
  @JsonValue("Analytics")
  Analytics,
  @JsonValue("Device")
  Device,
  @JsonValue("Events")
  Events,
  @JsonValue("Imaging")
  Imaging,
  @JsonValue("Media")
  Media,
  @JsonValue("PTZ")
  PTZ,
}

@JsonSerializable()
class Capabilities {
  /// Analytics capabilities
  @JsonKey(name: 'Analytics')
  final AnalyticsCapabilities? analytics;

  /// Device capabilities
  @JsonKey(name: 'Device')
  final DeviceCapabilities? device;

  /// Event capabilities
  @JsonKey(name: 'Events')
  final EventCapabilities? events;

  /// Imaging capabilities
  @JsonKey(name: 'Imaging')
  final ImagingCapabilities? imaging;

  /// Media capabilities
  @JsonKey(name: 'Media')
  final MediaCapabilities? media;

  /// PTZ capabilities
  @JsonKey(name: 'PTZ')
  final PTZCapabilities? pTZ;
  @JsonKey(name: 'Extension')
  final CapabilitiesExtension? extension_;
  Capabilities({
    this.analytics,
    this.device,
    this.events,
    this.imaging,
    this.media,
    this.pTZ,
    this.extension_,
  });
}

@JsonSerializable()
class CapabilitiesExtension {
  @JsonKey(name: 'DeviceIO')
  final DeviceIOCapabilities? deviceIO;
  @JsonKey(name: 'Display')
  final DisplayCapabilities? display;
  @JsonKey(name: 'Recording')
  final RecordingCapabilities? recording;
  @JsonKey(name: 'Search')
  final SearchCapabilities? search;
  @JsonKey(name: 'Replay')
  final ReplayCapabilities? replay;
  @JsonKey(name: 'Receiver')
  final ReceiverCapabilities? receiver;
  @JsonKey(name: 'AnalyticsDevice')
  final AnalyticsDeviceCapabilities? analyticsDevice;
  @JsonKey(name: 'Extensions')
  final CapabilitiesExtension2? extensions;
  CapabilitiesExtension({
    this.deviceIO,
    this.display,
    this.recording,
    this.search,
    this.replay,
    this.receiver,
    this.analyticsDevice,
    this.extensions,
  });
}

class CapabilitiesExtension2 {}

@JsonSerializable()
class AnalyticsCapabilities {
  /// Analytics service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Indicates whether or not rules are supported.
  @JsonKey(name: 'RuleSupport')
  final bool ruleSupport;

  /// Indicates whether or not modules are supported.
  @JsonKey(name: 'AnalyticsModuleSupport')
  final bool analyticsModuleSupport;
  AnalyticsCapabilities({
    required this.xAddr,
    required this.ruleSupport,
    required this.analyticsModuleSupport,
  });
}

@JsonSerializable()
class DeviceCapabilities {
  /// Device service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Network capabilities.
  @JsonKey(name: 'Network')
  final NetworkCapabilities? network;

  /// System capabilities.
  @JsonKey(name: 'System')
  final SystemCapabilities? system;

  /// I/O capabilities.
  @JsonKey(name: 'IO')
  final IOCapabilities? iO;

  /// Security capabilities.
  @JsonKey(name: 'Security')
  final SecurityCapabilities? security;
  @JsonKey(name: 'Extension')
  final DeviceCapabilitiesExtension? extension_;
  DeviceCapabilities({
    required this.xAddr,
    this.network,
    this.system,
    this.iO,
    this.security,
    this.extension_,
  });
}

class DeviceCapabilitiesExtension {}

@JsonSerializable()
class EventCapabilities {
  /// Event service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Indicates whether or not WS Subscription policy is supported.
  @JsonKey(name: 'WSSubscriptionPolicySupport')
  final bool wSSubscriptionPolicySupport;

  /// Indicates whether or not WS Pull Point is supported.
  @JsonKey(name: 'WSPullPointSupport')
  final bool wSPullPointSupport;

  /// Indicates whether or not WS Pausable Subscription Manager Interface is supported.
  @JsonKey(name: 'WSPausableSubscriptionManagerInterfaceSupport')
  final bool wSPausableSubscriptionManagerInterfaceSupport;
  EventCapabilities({
    required this.xAddr,
    required this.wSSubscriptionPolicySupport,
    required this.wSPullPointSupport,
    required this.wSPausableSubscriptionManagerInterfaceSupport,
  });
}

@JsonSerializable()
class IOCapabilities {
  /// Number of input connectors.
  @JsonKey(name: 'InputConnectors')
  final int? inputConnectors;

  /// Number of relay outputs.
  @JsonKey(name: 'RelayOutputs')
  final int? relayOutputs;
  @JsonKey(name: 'Extension')
  final IOCapabilitiesExtension? extension_;
  IOCapabilities({
    this.inputConnectors,
    this.relayOutputs,
    this.extension_,
  });
}

@JsonSerializable()
class IOCapabilitiesExtension {
  @JsonKey(name: 'Auxiliary')
  final bool? auxiliary;
  @JsonKey(name: 'AuxiliaryCommands')
  final AuxiliaryData? auxiliaryCommands;
  @JsonKey(name: 'Extension')
  final IOCapabilitiesExtension2 extension_;
  IOCapabilitiesExtension({
    this.auxiliary,
    this.auxiliaryCommands,
    required this.extension_,
  });
}

class IOCapabilitiesExtension2 {}

@JsonSerializable()
class MediaCapabilities {
  /// Media service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Streaming capabilities.
  @JsonKey(name: 'StreamingCapabilities')
  final RealTimeStreamingCapabilities streamingCapabilities;
  @JsonKey(name: 'Extension')
  final MediaCapabilitiesExtension? extension_;
  MediaCapabilities({
    required this.xAddr,
    required this.streamingCapabilities,
    this.extension_,
  });
}

@JsonSerializable()
class MediaCapabilitiesExtension {
  @JsonKey(name: 'ProfileCapabilities')
  final ProfileCapabilities profileCapabilities;
  MediaCapabilitiesExtension({
    required this.profileCapabilities,
  });
}

@JsonSerializable()
class RealTimeStreamingCapabilities {
  /// Indicates whether or not RTP multicast is supported.
  @JsonKey(name: 'RTPMulticast')
  final bool? rTPMulticast;

  /// Indicates whether or not RTP over TCP is supported.
  @JsonKey(name: 'RTP_TCP')
  final bool? rTP_TCP;

  /// Indicates whether or not RTP/RTSP/TCP is supported.
  @JsonKey(name: 'RTP_RTSP_TCP')
  final bool? rTP_RTSP_TCP;
  @JsonKey(name: 'Extension')
  final RealTimeStreamingCapabilitiesExtension? extension_;
  RealTimeStreamingCapabilities({
    this.rTPMulticast,
    this.rTP_TCP,
    this.rTP_RTSP_TCP,
    this.extension_,
  });
}

class RealTimeStreamingCapabilitiesExtension {}

@JsonSerializable()
class ProfileCapabilities {
  /// Maximum number of profiles.
  @JsonKey(name: 'MaximumNumberOfProfiles')
  final int maximumNumberOfProfiles;
  ProfileCapabilities({
    required this.maximumNumberOfProfiles,
  });
}

@JsonSerializable()
class NetworkCapabilities {
  /// Indicates whether or not IP filtering is supported.
  @JsonKey(name: 'IPFilter')
  final bool? iPFilter;

  /// Indicates whether or not zeroconf is supported.
  @JsonKey(name: 'ZeroConfiguration')
  final bool? zeroConfiguration;

  /// Indicates whether or not IPv6 is supported.
  @JsonKey(name: 'IPVersion6')
  final bool? iPVersion6;

  /// Indicates whether or not  is supported.
  @JsonKey(name: 'DynDNS')
  final bool? dynDNS;
  @JsonKey(name: 'Extension')
  final NetworkCapabilitiesExtension? extension_;
  NetworkCapabilities({
    this.iPFilter,
    this.zeroConfiguration,
    this.iPVersion6,
    this.dynDNS,
    this.extension_,
  });
}

@JsonSerializable()
class NetworkCapabilitiesExtension {
  @JsonKey(name: 'Dot11Configuration')
  final bool? dot11Configuration;
  @JsonKey(name: 'Extension')
  final NetworkCapabilitiesExtension2? extension_;
  NetworkCapabilitiesExtension({
    this.dot11Configuration,
    this.extension_,
  });
}

class NetworkCapabilitiesExtension2 {}

@JsonSerializable()
class SecurityCapabilities {
  /// Indicates whether or not TLS 1.1 is supported.
  @JsonKey(name: 'TLS1.1')
  final bool tLS1_1;

  /// Indicates whether or not TLS 1.2 is supported.
  @JsonKey(name: 'TLS1.2')
  final bool tLS1_2;

  /// Indicates whether or not onboard key generation is supported.
  @JsonKey(name: 'OnboardKeyGeneration')
  final bool onboardKeyGeneration;

  /// Indicates whether or not access policy configuration is supported.
  @JsonKey(name: 'AccessPolicyConfig')
  final bool accessPolicyConfig;

  /// Indicates whether or not WS-Security X.509 token is supported.
  @JsonKey(name: 'X.509Token')
  final bool x_509Token;

  /// Indicates whether or not WS-Security SAML token is supported.
  @JsonKey(name: 'SAMLToken')
  final bool sAMLToken;

  /// Indicates whether or not WS-Security Kerberos token is supported.
  @JsonKey(name: 'KerberosToken')
  final bool kerberosToken;

  /// Indicates whether or not WS-Security REL token is supported.
  @JsonKey(name: 'RELToken')
  final bool rELToken;
  @JsonKey(name: 'Extension')
  final SecurityCapabilitiesExtension? extension_;
  SecurityCapabilities({
    required this.tLS1_1,
    required this.tLS1_2,
    required this.onboardKeyGeneration,
    required this.accessPolicyConfig,
    required this.x_509Token,
    required this.sAMLToken,
    required this.kerberosToken,
    required this.rELToken,
    this.extension_,
  });
}

@JsonSerializable()
class SecurityCapabilitiesExtension {
  @JsonKey(name: 'TLS1.0')
  final bool tLS1_0;
  @JsonKey(name: 'Extension')
  final SecurityCapabilitiesExtension2? extension_;
  SecurityCapabilitiesExtension({
    required this.tLS1_0,
    this.extension_,
  });
}

@JsonSerializable()
class SecurityCapabilitiesExtension2 {
  @JsonKey(name: 'Dot1X')
  final bool dot1X;

  /// EAP Methods supported by the device. The int values refer to the IANA EAP Registry.
  @JsonKey(name: 'SupportedEAPMethod')
  final int? supportedEAPMethod;
  @JsonKey(name: 'RemoteUserHandling')
  final bool remoteUserHandling;
  SecurityCapabilitiesExtension2({
    required this.dot1X,
    this.supportedEAPMethod,
    required this.remoteUserHandling,
  });
}

@JsonSerializable()
class SystemCapabilities {
  /// Indicates whether or not WS Discovery resolve requests are supported.
  @JsonKey(name: 'DiscoveryResolve')
  final bool discoveryResolve;

  /// Indicates whether or not WS-Discovery Bye is supported.
  @JsonKey(name: 'DiscoveryBye')
  final bool discoveryBye;

  /// Indicates whether or not remote discovery is supported.
  @JsonKey(name: 'RemoteDiscovery')
  final bool remoteDiscovery;

  /// Indicates whether or not system backup is supported.
  @JsonKey(name: 'SystemBackup')
  final bool systemBackup;

  /// Indicates whether or not system logging is supported.
  @JsonKey(name: 'SystemLogging')
  final bool systemLogging;

  /// Indicates whether or not firmware upgrade is supported.
  @JsonKey(name: 'FirmwareUpgrade')
  final bool firmwareUpgrade;

  /// Indicates supported ONVIF version(s).
  @JsonKey(name: 'SupportedVersions')
  final OnvifVersion supportedVersions;
  @JsonKey(name: 'Extension')
  final SystemCapabilitiesExtension? extension_;
  SystemCapabilities({
    required this.discoveryResolve,
    required this.discoveryBye,
    required this.remoteDiscovery,
    required this.systemBackup,
    required this.systemLogging,
    required this.firmwareUpgrade,
    required this.supportedVersions,
    this.extension_,
  });
}

@JsonSerializable()
class SystemCapabilitiesExtension {
  @JsonKey(name: 'HttpFirmwareUpgrade')
  final bool? httpFirmwareUpgrade;
  @JsonKey(name: 'HttpSystemBackup')
  final bool? httpSystemBackup;
  @JsonKey(name: 'HttpSystemLogging')
  final bool? httpSystemLogging;
  @JsonKey(name: 'HttpSupportInformation')
  final bool? httpSupportInformation;
  @JsonKey(name: 'Extension')
  final SystemCapabilitiesExtension2? extension_;
  SystemCapabilitiesExtension({
    this.httpFirmwareUpgrade,
    this.httpSystemBackup,
    this.httpSystemLogging,
    this.httpSupportInformation,
    this.extension_,
  });
}

class SystemCapabilitiesExtension2 {}

@JsonSerializable()
class OnvifVersion {
  /// Major version number.
  @JsonKey(name: 'Major')
  final int major;

  ///
  /// Two digit minor version number.
  /// If major version number is less than "16", X.0.1 maps to "01" and X.2.1 maps to "21" where X stands for Major version number.
  /// Otherwise, minor number is month of release, such as "06" for June.
  ///
  @JsonKey(name: 'Minor')
  final int minor;
  OnvifVersion({
    required this.major,
    required this.minor,
  });
}

@JsonSerializable()
class ImagingCapabilities {
  /// Imaging service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;
  ImagingCapabilities({
    required this.xAddr,
  });
}

@JsonSerializable()
class PTZCapabilities {
  /// PTZ service URI.
  @JsonKey(name: 'XAddr')
  final String xAddr;
  PTZCapabilities({
    required this.xAddr,
  });
}

@JsonSerializable()
class DeviceIOCapabilities {
  @JsonKey(name: 'XAddr')
  final String xAddr;
  @JsonKey(name: 'VideoSources')
  final int videoSources;
  @JsonKey(name: 'VideoOutputs')
  final int videoOutputs;
  @JsonKey(name: 'AudioSources')
  final int audioSources;
  @JsonKey(name: 'AudioOutputs')
  final int audioOutputs;
  @JsonKey(name: 'RelayOutputs')
  final int relayOutputs;
  DeviceIOCapabilities({
    required this.xAddr,
    required this.videoSources,
    required this.videoOutputs,
    required this.audioSources,
    required this.audioOutputs,
    required this.relayOutputs,
  });
}

@JsonSerializable()
class DisplayCapabilities {
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Indication that the SetLayout command supports only predefined layouts.
  @JsonKey(name: 'FixedLayout')
  final bool fixedLayout;
  DisplayCapabilities({
    required this.xAddr,
    required this.fixedLayout,
  });
}

@JsonSerializable()
class RecordingCapabilities {
  @JsonKey(name: 'XAddr')
  final String xAddr;
  @JsonKey(name: 'ReceiverSource')
  final bool receiverSource;
  @JsonKey(name: 'MediaProfileSource')
  final bool mediaProfileSource;
  @JsonKey(name: 'DynamicRecordings')
  final bool dynamicRecordings;
  @JsonKey(name: 'DynamicTracks')
  final bool dynamicTracks;
  @JsonKey(name: 'MaxStringLength')
  final int maxStringLength;
  RecordingCapabilities({
    required this.xAddr,
    required this.receiverSource,
    required this.mediaProfileSource,
    required this.dynamicRecordings,
    required this.dynamicTracks,
    required this.maxStringLength,
  });
}

@JsonSerializable()
class SearchCapabilities {
  @JsonKey(name: 'XAddr')
  final String xAddr;
  @JsonKey(name: 'MetadataSearch')
  final bool metadataSearch;
  SearchCapabilities({
    required this.xAddr,
    required this.metadataSearch,
  });
}

@JsonSerializable()
class ReplayCapabilities {
  /// The address of the replay service.
  @JsonKey(name: 'XAddr')
  final String xAddr;
  ReplayCapabilities({
    required this.xAddr,
  });
}

@JsonSerializable()
class ReceiverCapabilities {
  /// The address of the receiver service.
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Indicates whether the device can receive RTP multicast streams.
  @JsonKey(name: 'RTP_Multicast')
  final bool rTP_Multicast;

  /// Indicates whether the device can receive RTP/TCP streams
  @JsonKey(name: 'RTP_TCP')
  final bool rTP_TCP;

  /// Indicates whether the device can receive RTP/RTSP/TCP streams.
  @JsonKey(name: 'RTP_RTSP_TCP')
  final bool rTP_RTSP_TCP;

  /// The maximum number of receivers supported by the device.
  @JsonKey(name: 'SupportedReceivers')
  final int supportedReceivers;

  /// The maximum allowed length for RTSP URIs.
  @JsonKey(name: 'MaximumRTSPURILength')
  final int maximumRTSPURILength;
  ReceiverCapabilities({
    required this.xAddr,
    required this.rTP_Multicast,
    required this.rTP_TCP,
    required this.rTP_RTSP_TCP,
    required this.supportedReceivers,
    required this.maximumRTSPURILength,
  });
}

@JsonSerializable()
class AnalyticsDeviceCapabilities {
  @JsonKey(name: 'XAddr')
  final String xAddr;

  /// Obsolete property.
  @JsonKey(name: 'RuleSupport')
  final bool? ruleSupport;
  @JsonKey(name: 'Extension')
  final AnalyticsDeviceExtension? extension_;
  AnalyticsDeviceCapabilities({
    required this.xAddr,
    this.ruleSupport,
    this.extension_,
  });
}

class AnalyticsDeviceExtension {}

/// Enumeration describing the available system log modes.
enum SystemLogType {
  @JsonValue("System")
  System,
  @JsonValue("Access")
  Access,
}

@JsonSerializable()
class SystemLog {
  /// The log information as attachment data.
  @JsonKey(name: 'Binary')
  final AttachmentData? binary;

  /// The log information as character data.
  @JsonKey(name: 'String')
  final String? string;
  SystemLog({
    this.binary,
    this.string,
  });
}

@JsonSerializable()
class SupportInformation {
  /// The support information as attachment data.
  @JsonKey(name: 'Binary')
  final AttachmentData? binary;

  /// The support information as character data.
  @JsonKey(name: 'String')
  final String? string;
  SupportInformation({
    this.binary,
    this.string,
  });
}

@JsonSerializable()
class BinaryData {
  /// base64 encoded binary data.
  @JsonKey(name: 'Data')
  final Uint8List data;
  BinaryData({
    required this.data,
  });
}

class AttachmentData {}

@JsonSerializable()
class BackupFile {
  @JsonKey(name: 'Name')
  final String name;
  @JsonKey(name: 'Data')
  final AttachmentData data;
  BackupFile({
    required this.name,
    required this.data,
  });
}

@JsonSerializable()
class SystemLogUriList {
  @JsonKey(name: 'SystemLog')
  final SystemLogUri? systemLog;
  SystemLogUriList({
    this.systemLog,
  });
}

@JsonSerializable()
class SystemLogUri {
  @JsonKey(name: 'Type')
  final SystemLogType type;
  @JsonKey(name: 'Uri')
  final String uri;
  SystemLogUri({
    required this.type,
    required this.uri,
  });
}

/// Enumeration describing the available factory default modes.
enum FactoryDefaultType {
  @JsonValue("Hard")
  Hard,
  @JsonValue("Soft")
  Soft,
}

enum SetDateTimeType {
  @JsonValue("Manual")
  Manual,
  @JsonValue("NTP")
  NTP,
}

/// General date time inforamtion returned by the GetSystemDateTime method.
@JsonSerializable()
class SystemDateTime {
  /// Indicates if the time is set manully or through NTP.
  @JsonKey(name: 'DateTimeType')
  final SetDateTimeType dateTimeType;

  /// Informative indicator whether daylight savings is currently on/off.
  @JsonKey(name: 'DaylightSavings')
  final bool daylightSavings;

  /// Timezone information in Posix format.
  @JsonKey(name: 'TimeZone')
  final TimeZone? timeZone;

  /// Current system date and time in UTC format. This field is mandatory since version 2.0.
  @JsonKey(name: 'UTCDateTime')
  final DateTime? uTCDateTime;

  /// Date and time in local format.
  @JsonKey(name: 'LocalDateTime')
  final DateTime? localDateTime;
  @JsonKey(name: 'Extension')
  final SystemDateTimeExtension? extension_;
  SystemDateTime({
    required this.dateTimeType,
    required this.daylightSavings,
    this.timeZone,
    this.uTCDateTime,
    this.localDateTime,
    this.extension_,
  });
}

class SystemDateTimeExtension {}

@JsonSerializable()
class DateTime {
  @JsonKey(name: 'Time')
  final Time time;
  @JsonKey(name: 'Date')
  final Date date;
  DateTime({
    required this.time,
    required this.date,
  });
}

@JsonSerializable()
class Date {
  @JsonKey(name: 'Year')
  final int year;

  /// Range is 1 to 12.
  @JsonKey(name: 'Month')
  final int month;

  /// Range is 1 to 31.
  @JsonKey(name: 'Day')
  final int day;
  Date({
    required this.year,
    required this.month,
    required this.day,
  });
}

@JsonSerializable()
class Time {
  /// Range is 0 to 23.
  @JsonKey(name: 'Hour')
  final int hour;

  /// Range is 0 to 59.
  @JsonKey(name: 'Minute')
  final int minute;

  /// Range is 0 to 61 (typically 59).
  @JsonKey(name: 'Second')
  final int second;
  Time({
    required this.hour,
    required this.minute,
    required this.second,
  });
}

///
/// The TZ format is specified by POSIX, please refer to POSIX 1003.1 section 8.3
/// Example: Europe, Paris TZ=CET-1CEST,M3.5.0/2,M10.5.0/3
/// CET = designation for standard time when daylight saving is not in force
/// -1 = offset in hours = negative so 1 hour east of Greenwich meridian
/// CEST = designation when daylight saving is in force ("Central European Summer Time")
/// , = no offset number between code and comma, so default to one hour ahead for daylight saving
/// M3.5.0 = when daylight saving starts = the last Sunday in March (the "5th" week means the last in the month)
/// /2, = the local time when the switch occurs = 2 a.m. in this case
/// M10.5.0 = when daylight saving ends = the last Sunday in October.
/// /3, = the local time when the switch occurs = 3 a.m. in this case
///
@JsonSerializable()
class TimeZone {
  /// Posix timezone string.
  @JsonKey(name: 'TZ')
  final String tZ;
  TimeZone({
    required this.tZ,
  });
}

@JsonSerializable()
class RemoteUser {
  @JsonKey(name: 'Username')
  final String username;
  @JsonKey(name: 'Password')
  final String? password;
  @JsonKey(name: 'UseDerivedPassword')
  final bool useDerivedPassword;
  RemoteUser({
    required this.username,
    this.password,
    required this.useDerivedPassword,
  });
}

enum UserLevel {
  @JsonValue("Administrator")
  Administrator,
  @JsonValue("Operator")
  Operator_,
  @JsonValue("User")
  User,
  @JsonValue("Anonymous")
  Anonymous,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class User {
  /// Username string.
  @JsonKey(name: 'Username')
  final String username;

  /// Password string.
  @JsonKey(name: 'Password')
  final String? password;

  /// User level string.
  @JsonKey(name: 'UserLevel')
  final UserLevel userLevel;
  @JsonKey(name: 'Extension')
  final UserExtension? extension_;
  User({
    required this.username,
    this.password,
    required this.userLevel,
    this.extension_,
  });
}

class UserExtension {}

@JsonSerializable()
class CertificateGenerationParameters {
  @JsonKey(name: 'CertificateID')
  final String? certificateID;
  @JsonKey(name: 'Subject')
  final String? subject;
  @JsonKey(name: 'ValidNotBefore')
  final String? validNotBefore;
  @JsonKey(name: 'ValidNotAfter')
  final String? validNotAfter;
  @JsonKey(name: 'Extension')
  final CertificateGenerationParametersExtension? extension_;
  CertificateGenerationParameters({
    this.certificateID,
    this.subject,
    this.validNotBefore,
    this.validNotAfter,
    this.extension_,
  });
}

class CertificateGenerationParametersExtension {}

@JsonSerializable()
class Certificate {
  /// Certificate id.
  @JsonKey(name: 'CertificateID')
  final String certificateID;

  /// base64 encoded DER representation of certificate.
  @JsonKey(name: 'Certificate')
  final BinaryData certificate;
  Certificate({
    required this.certificateID,
    required this.certificate,
  });
}

@JsonSerializable()
class CertificateStatus {
  /// Certificate id.
  @JsonKey(name: 'CertificateID')
  final String certificateID;

  /// Indicates whether or not a certificate is used in a HTTPS configuration.
  @JsonKey(name: 'Status')
  final bool status;
  CertificateStatus({
    required this.certificateID,
    required this.status,
  });
}

@JsonSerializable()
class CertificateWithPrivateKey {
  @JsonKey(name: 'CertificateID')
  final String? certificateID;
  @JsonKey(name: 'Certificate')
  final BinaryData certificate;
  @JsonKey(name: 'PrivateKey')
  final BinaryData privateKey;
  CertificateWithPrivateKey({
    this.certificateID,
    required this.certificate,
    required this.privateKey,
  });
}

@JsonSerializable()
class CertificateInformation {
  @JsonKey(name: 'CertificateID')
  final String certificateID;
  @JsonKey(name: 'IssuerDN')
  final String? issuerDN;
  @JsonKey(name: 'SubjectDN')
  final String? subjectDN;
  @JsonKey(name: 'KeyUsage')
  final CertificateUsage? keyUsage;
  @JsonKey(name: 'ExtendedKeyUsage')
  final CertificateUsage? extendedKeyUsage;
  @JsonKey(name: 'KeyLength')
  final int? keyLength;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'SerialNum')
  final String? serialNum;

  /// Validity Range is from "NotBefore" to "NotAfter"; the corresponding DateTimeRange is from "From" to "Until"
  @JsonKey(name: 'SignatureAlgorithm')
  final String? signatureAlgorithm;
  @JsonKey(name: 'Validity')
  final DateTimeRange? validity;
  @JsonKey(name: 'Extension')
  final CertificateInformationExtension? extension_;
  CertificateInformation({
    required this.certificateID,
    this.issuerDN,
    this.subjectDN,
    this.keyUsage,
    this.extendedKeyUsage,
    this.keyLength,
    this.version,
    this.serialNum,
    this.signatureAlgorithm,
    this.validity,
    this.extension_,
  });
}

@JsonSerializable()
class CertificateUsage {
  @JsonKey(name: 'value')
  final String value;
  @JsonKey(name: 'Critical')
  final bool critical;
  CertificateUsage({
    required this.value,
    required this.critical,
  });
}

class CertificateInformationExtension {}

@JsonSerializable()
class Dot1XConfiguration {
  @JsonKey(name: 'Dot1XConfigurationToken')
  final ReferenceToken dot1XConfigurationToken;
  @JsonKey(name: 'Identity')
  final String identity;
  @JsonKey(name: 'AnonymousID')
  final String? anonymousID;

  ///
  /// EAP Method type as defined in IANA EAP Registry.
  ///
  @JsonKey(name: 'EAPMethod')
  final int eAPMethod;
  @JsonKey(name: 'CACertificateID')
  final String? cACertificateID;
  @JsonKey(name: 'EAPMethodConfiguration')
  final EAPMethodConfiguration? eAPMethodConfiguration;
  @JsonKey(name: 'Extension')
  final Dot1XConfigurationExtension? extension_;
  Dot1XConfiguration({
    required this.dot1XConfigurationToken,
    required this.identity,
    this.anonymousID,
    required this.eAPMethod,
    this.cACertificateID,
    this.eAPMethodConfiguration,
    this.extension_,
  });
}

class Dot1XConfigurationExtension {}

@JsonSerializable()
class EAPMethodConfiguration {
  /// Confgiuration information for TLS Method.
  @JsonKey(name: 'TLSConfiguration')
  final TLSConfiguration? tLSConfiguration;

  /// Password for those EAP Methods that require a password. The password shall never be returned on a get method.
  @JsonKey(name: 'Password')
  final String? password;
  @JsonKey(name: 'Extension')
  final EapMethodExtension? extension_;
  EAPMethodConfiguration({
    this.tLSConfiguration,
    this.password,
    this.extension_,
  });
}

class EapMethodExtension {}

@JsonSerializable()
class TLSConfiguration {
  @JsonKey(name: 'CertificateID')
  final String certificateID;
  TLSConfiguration({
    required this.certificateID,
  });
}

class GenericEapPwdConfigurationExtension {}

enum RelayLogicalState {
  @JsonValue("active")
  active,
  @JsonValue("inactive")
  inactive,
}

enum RelayIdleState {
  @JsonValue("closed")
  closed,
  @JsonValue("open")
  open,
}

@JsonSerializable()
class RelayOutputSettings {
  ///
  /// 'Bistable' or 'Monostable'
  ///
  /// Bistable – After setting the state, the relay remains in this state.
  /// Monostable – After setting the state, the relay returns to its idle state after the specified time.
  ///
  ///
  @JsonKey(name: 'Mode')
  final RelayMode mode;

  /// Time after which the relay returns to its idle state if it is in monostable mode. If the Mode field is set to bistable mode the value of the parameter can be ignored.
  @JsonKey(name: 'DelayTime')
  final Duration delayTime;

  ///
  /// 'open' or 'closed'
  ///
  /// 'open' means that the relay is open when the relay state is set to 'inactive' through the trigger command and closed when the state is set to 'active' through the same command.
  /// 'closed' means that the relay is closed when the relay state is set to 'inactive' through the trigger command and open when the state is set to 'active' through the same command.
  ///
  ///
  @JsonKey(name: 'IdleState')
  final RelayIdleState idleState;
  RelayOutputSettings({
    required this.mode,
    required this.delayTime,
    required this.idleState,
  });
}

enum RelayMode {
  @JsonValue("Monostable")
  Monostable,
  @JsonValue("Bistable")
  Bistable,
}

class RelayOutput {}

enum DigitalIdleState {
  @JsonValue("closed")
  closed,
  @JsonValue("open")
  open,
}

class DigitalInput {}

class PTZNode {}

@JsonSerializable()
class PTZNodeExtension {
  ///
  ///             Detail of supported Preset Tour feature.
  ///
  @JsonKey(name: 'SupportedPresetTour')
  final PTZPresetTourSupported? supportedPresetTour;
  @JsonKey(name: 'Extension')
  final PTZNodeExtension2? extension_;
  PTZNodeExtension({
    this.supportedPresetTour,
    this.extension_,
  });
}

class PTZNodeExtension2 {}

@JsonSerializable()
class PTZPresetTourSupported {
  /// Indicates number of preset tours that can be created. Required preset tour operations shall be available for this PTZ Node if one or more preset tour is supported.
  @JsonKey(name: 'MaximumNumberOfPresetTours')
  final int maximumNumberOfPresetTours;

  /// Indicates which preset tour operations are available for this PTZ Node.
  @JsonKey(name: 'PTZPresetTourOperation')
  final PTZPresetTourOperation? pTZPresetTourOperation;
  @JsonKey(name: 'Extension')
  final PTZPresetTourSupportedExtension? extension_;
  PTZPresetTourSupported({
    required this.maximumNumberOfPresetTours,
    this.pTZPresetTourOperation,
    this.extension_,
  });
}

class PTZPresetTourSupportedExtension {}

class PTZConfiguration {}

@JsonSerializable()
class PTZConfigurationExtension {
  /// Optional element to configure PT Control Direction related features.
  @JsonKey(name: 'PTControlDirection')
  final PTControlDirection? pTControlDirection;
  @JsonKey(name: 'Extension')
  final PTZConfigurationExtension2? extension_;
  PTZConfigurationExtension({
    this.pTControlDirection,
    this.extension_,
  });
}

class PTZConfigurationExtension2 {}

@JsonSerializable()
class PTControlDirection {
  /// Optional element to configure related parameters for E-Flip.
  @JsonKey(name: 'EFlip')
  final EFlip? eFlip;

  /// Optional element to configure related parameters for reversing of PT Control Direction.
  @JsonKey(name: 'Reverse')
  final Reverse? reverse;
  @JsonKey(name: 'Extension')
  final PTControlDirectionExtension? extension_;
  PTControlDirection({
    this.eFlip,
    this.reverse,
    this.extension_,
  });
}

class PTControlDirectionExtension {}

@JsonSerializable()
class EFlip {
  /// Parameter to enable/disable E-Flip feature.
  @JsonKey(name: 'Mode')
  final EFlipMode mode;
  EFlip({
    required this.mode,
  });
}

@JsonSerializable()
class Reverse {
  /// Parameter to enable/disable Reverse feature.
  @JsonKey(name: 'Mode')
  final ReverseMode mode;
  Reverse({
    required this.mode,
  });
}

enum EFlipMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("Extended")
  Extended,
}

enum ReverseMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("AUTO")
  AUTO,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class PTZConfigurationOptions {
  ///
  ///             A list of supported coordinate systems including their range limitations.
  ///
  @JsonKey(name: 'Spaces')
  final PTZSpaces spaces;

  ///
  ///             A timeout Range within which Timeouts are accepted by the PTZ Node.
  ///
  @JsonKey(name: 'PTZTimeout')
  final DurationRange pTZTimeout;

  /// Supported options for PT Direction Control.
  @JsonKey(name: 'PTControlDirection')
  final PTControlDirectionOptions? pTControlDirection;
  @JsonKey(name: 'Extension')
  final PTZConfigurationOptions2? extension_;

  ///
  /// The list of acceleration ramps supported by the device. The
  /// smallest acceleration value corresponds to the minimal index, the
  /// highest acceleration corresponds to the maximum index.
  ///
  @JsonKey(name: 'PTZRamps')
  final IntAttrList pTZRamps;
  PTZConfigurationOptions({
    required this.spaces,
    required this.pTZTimeout,
    this.pTControlDirection,
    this.extension_,
    required this.pTZRamps,
  });
}

class PTZConfigurationOptions2 {}

@JsonSerializable()
class PTControlDirectionOptions {
  /// Supported options for EFlip feature.
  @JsonKey(name: 'EFlip')
  final EFlipOptions? eFlip;

  /// Supported options for Reverse feature.
  @JsonKey(name: 'Reverse')
  final ReverseOptions? reverse;
  @JsonKey(name: 'Extension')
  final PTControlDirectionOptionsExtension? extension_;
  PTControlDirectionOptions({
    this.eFlip,
    this.reverse,
    this.extension_,
  });
}

class PTControlDirectionOptionsExtension {}

@JsonSerializable()
class EFlipOptions {
  /// Options of EFlip mode parameter.
  @JsonKey(name: 'Mode')
  final EFlipMode? mode;
  @JsonKey(name: 'Extension')
  final EFlipOptionsExtension? extension_;
  EFlipOptions({
    this.mode,
    this.extension_,
  });
}

class EFlipOptionsExtension {}

@JsonSerializable()
class ReverseOptions {
  /// Options of Reverse mode parameter.
  @JsonKey(name: 'Mode')
  final ReverseMode? mode;
  @JsonKey(name: 'Extension')
  final ReverseOptionsExtension? extension_;
  ReverseOptions({
    this.mode,
    this.extension_,
  });
}

class ReverseOptionsExtension {}

@JsonSerializable()
class PanTiltLimits {
  ///
  ///             A range of pan tilt limits.
  ///
  @JsonKey(name: 'Range')
  final Space2DDescription range;
  PanTiltLimits({
    required this.range,
  });
}

@JsonSerializable()
class ZoomLimits {
  ///
  ///             A range of zoom limit
  ///
  @JsonKey(name: 'Range')
  final Space1DDescription range;
  ZoomLimits({
    required this.range,
  });
}

@JsonSerializable()
class PTZSpaces {
  ///
  ///             The Generic Pan/Tilt Position space is provided by every PTZ node that supports absolute Pan/Tilt, since it does not relate to a specific physical range.
  /// Instead, the range should be defined as the full range of the PTZ unit normalized to the range -1 to 1 resulting in the following space description.
  ///
  @JsonKey(name: 'AbsolutePanTiltPositionSpace')
  final Space2DDescription? absolutePanTiltPositionSpace;

  ///
  ///             The Generic Zoom Position Space is provided by every PTZ node that supports absolute Zoom, since it does not relate to a specific physical range.
  /// Instead, the range should be defined as the full range of the Zoom normalized to the range 0 (wide) to 1 (tele).
  /// There is no assumption about how the generic zoom range is mapped to magnification, FOV or other physical zoom dimension.
  ///
  @JsonKey(name: 'AbsoluteZoomPositionSpace')
  final Space1DDescription? absoluteZoomPositionSpace;

  ///
  ///             The Generic Pan/Tilt translation space is provided by every PTZ node that supports relative Pan/Tilt, since it does not relate to a specific physical range.
  /// Instead, the range should be defined as the full positive and negative translation range of the PTZ unit normalized to the range -1 to 1,
  /// where positive translation would mean clockwise rotation or movement in right/up direction resulting in the following space description.
  ///
  @JsonKey(name: 'RelativePanTiltTranslationSpace')
  final Space2DDescription? relativePanTiltTranslationSpace;

  ///
  ///             The Generic Zoom Translation Space is provided by every PTZ node that supports relative Zoom, since it does not relate to a specific physical range.
  /// Instead, the corresponding absolute range should be defined as the full positive and negative translation range of the Zoom normalized to the range -1 to1,
  /// where a positive translation maps to a movement in TELE direction. The translation is signed to indicate direction (negative is to wide, positive is to tele).
  /// There is no assumption about how the generic zoom range is mapped to magnification, FOV or other physical zoom dimension. This results in the following space description.
  ///
  @JsonKey(name: 'RelativeZoomTranslationSpace')
  final Space1DDescription? relativeZoomTranslationSpace;

  ///
  ///             The generic Pan/Tilt velocity space shall be provided by every PTZ node, since it does not relate to a specific physical range.
  /// Instead, the range should be defined as a range of the PTZ unit’s speed normalized to the range -1 to 1, where a positive velocity would map to clockwise
  /// rotation or movement in the right/up direction. A signed speed can be independently specified for the pan and tilt component resulting in the following space description.
  ///
  @JsonKey(name: 'ContinuousPanTiltVelocitySpace')
  final Space2DDescription? continuousPanTiltVelocitySpace;

  ///
  ///             The generic zoom velocity space specifies a zoom factor velocity without knowing the underlying physical model. The range should be normalized from -1 to 1,
  /// where a positive velocity would map to TELE direction. A generic zoom velocity space description resembles the following.
  ///
  @JsonKey(name: 'ContinuousZoomVelocitySpace')
  final Space1DDescription? continuousZoomVelocitySpace;

  ///
  ///             The speed space specifies the speed for a Pan/Tilt movement when moving to an absolute position or to a relative translation.
  /// In contrast to the velocity spaces, speed spaces do not contain any directional information. The speed of a combined Pan/Tilt
  /// movement is represented by a single non-negative scalar value.
  ///
  @JsonKey(name: 'PanTiltSpeedSpace')
  final Space1DDescription? panTiltSpeedSpace;

  ///
  ///             The speed space specifies the speed for a Zoom movement when moving to an absolute position or to a relative translation.
  /// In contrast to the velocity spaces, speed spaces do not contain any directional information.
  ///
  @JsonKey(name: 'ZoomSpeedSpace')
  final Space1DDescription? zoomSpeedSpace;
  @JsonKey(name: 'Extension')
  final PTZSpacesExtension? extension_;
  PTZSpaces({
    this.absolutePanTiltPositionSpace,
    this.absoluteZoomPositionSpace,
    this.relativePanTiltTranslationSpace,
    this.relativeZoomTranslationSpace,
    this.continuousPanTiltVelocitySpace,
    this.continuousZoomVelocitySpace,
    this.panTiltSpeedSpace,
    this.zoomSpeedSpace,
    this.extension_,
  });
}

class PTZSpacesExtension {}

@JsonSerializable()
class Space2DDescription {
  ///
  ///             A URI of coordinate systems.
  ///
  @JsonKey(name: 'URI')
  final String uRI;

  ///
  ///             A range of x-axis.
  ///
  @JsonKey(name: 'XRange')
  final FloatRange xRange;

  ///
  ///             A range of y-axis.
  ///
  @JsonKey(name: 'YRange')
  final FloatRange yRange;
  Space2DDescription({
    required this.uRI,
    required this.xRange,
    required this.yRange,
  });
}

@JsonSerializable()
class Space1DDescription {
  ///
  ///             A URI of coordinate systems.
  ///
  @JsonKey(name: 'URI')
  final String uRI;

  ///
  ///             A range of x-axis.
  ///
  @JsonKey(name: 'XRange')
  final FloatRange xRange;
  Space1DDescription({
    required this.uRI,
    required this.xRange,
  });
}

@JsonSerializable()
class PTZSpeed {
  /// Pan and tilt speed. The x component corresponds to pan and the y component to tilt. If omitted in a request, the current (if any) PanTilt movement should not be affected.
  @JsonKey(name: 'PanTilt')
  final Vector2D? panTilt;

  ///
  ///             A zoom speed. If omitted in a request, the current (if any) Zoom movement should not be affected.
  ///
  @JsonKey(name: 'Zoom')
  final Vector1D? zoom;
  PTZSpeed({
    this.panTilt,
    this.zoom,
  });
}

@JsonSerializable()
class PTZPreset {
  ///
  ///             A list of preset position name.
  ///
  @JsonKey(name: 'Name')
  final String? name;

  ///
  ///             A list of preset position.
  ///
  @JsonKey(name: 'PTZPosition')
  final PTZVector? pTZPosition;

  ///
  ///
  @JsonKey(name: 'token')
  final ReferenceToken token;
  PTZPreset({
    this.name,
    this.pTZPosition,
    required this.token,
  });
}

@JsonSerializable()
class AuxiliaryData {
  @JsonKey(name: 'val')
  final String val;
  AuxiliaryData({
    required this.val,
  });
}

enum PTZPresetTourState {
  @JsonValue("Idle")
  Idle,
  @JsonValue("Touring")
  Touring,
  @JsonValue("Paused")
  Paused,
  @JsonValue("Extended")
  Extended,
}

enum PTZPresetTourDirection {
  @JsonValue("Forward")
  Forward,
  @JsonValue("Backward")
  Backward,
  @JsonValue("Extended")
  Extended,
}

enum PTZPresetTourOperation {
  @JsonValue("Start")
  Start,
  @JsonValue("Stop")
  Stop,
  @JsonValue("Pause")
  Pause,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class PresetTour {
  /// Readable name of the preset tour.
  @JsonKey(name: 'Name')
  final String? name;

  /// Read only parameters to indicate the status of the preset tour.
  @JsonKey(name: 'Status')
  final PTZPresetTourStatus status;

  /// Auto Start flag of the preset tour. True allows the preset tour to be activated always.
  @JsonKey(name: 'AutoStart')
  final bool autoStart;

  /// Parameters to specify the detail behavior of the preset tour.
  @JsonKey(name: 'StartingCondition')
  final PTZPresetTourStartingCondition startingCondition;

  /// A list of detail of touring spots including preset positions.
  @JsonKey(name: 'TourSpot')
  final PTZPresetTourSpot? tourSpot;
  @JsonKey(name: 'Extension')
  final PTZPresetTourExtension? extension_;

  /// Unique identifier of this preset tour.
  @JsonKey(name: 'token')
  final ReferenceToken token;
  PresetTour({
    this.name,
    required this.status,
    required this.autoStart,
    required this.startingCondition,
    this.tourSpot,
    this.extension_,
    required this.token,
  });
}

class PTZPresetTourExtension {}

@JsonSerializable()
class PTZPresetTourSpot {
  /// Detail definition of preset position of the tour spot.
  @JsonKey(name: 'PresetDetail')
  final PTZPresetTourPresetDetail presetDetail;

  /// Optional parameter to specify Pan/Tilt and Zoom speed on moving toward this tour spot.
  @JsonKey(name: 'Speed')
  final PTZSpeed? speed;

  /// Optional parameter to specify time duration of staying on this tour sport.
  @JsonKey(name: 'StayTime')
  final Duration? stayTime;
  @JsonKey(name: 'Extension')
  final PTZPresetTourSpotExtension? extension_;
  PTZPresetTourSpot({
    required this.presetDetail,
    this.speed,
    this.stayTime,
    this.extension_,
  });
}

class PTZPresetTourSpotExtension {}

class PTZPresetTourPresetDetail {}

class PTZPresetTourTypeExtension {}

@JsonSerializable()
class PTZPresetTourStatus {
  /// Indicates state of this preset tour by Idle/Touring/Paused.
  @JsonKey(name: 'State')
  final PTZPresetTourState state;

  /// Indicates a tour spot currently staying.
  @JsonKey(name: 'CurrentTourSpot')
  final PTZPresetTourSpot? currentTourSpot;
  @JsonKey(name: 'Extension')
  final PTZPresetTourStatusExtension? extension_;
  PTZPresetTourStatus({
    required this.state,
    this.currentTourSpot,
    this.extension_,
  });
}

class PTZPresetTourStatusExtension {}

@JsonSerializable()
class PTZPresetTourStartingCondition {
  /// Optional parameter to specify how many times the preset tour is recurred.
  @JsonKey(name: 'RecurringTime')
  final int? recurringTime;

  /// Optional parameter to specify how long time duration the preset tour is recurred.
  @JsonKey(name: 'RecurringDuration')
  final Duration? recurringDuration;

  /// Optional parameter to choose which direction the preset tour goes. Forward shall be chosen in case it is omitted.
  @JsonKey(name: 'Direction')
  final PTZPresetTourDirection? direction;
  @JsonKey(name: 'Extension')
  final PTZPresetTourStartingConditionExtension? extension_;

  /// Execute presets in random order. If set to true and Direction is also present, Direction will be ignored and presets of the Tour will be recalled randomly.
  @JsonKey(name: 'RandomPresetOrder')
  final bool randomPresetOrder;
  PTZPresetTourStartingCondition({
    this.recurringTime,
    this.recurringDuration,
    this.direction,
    this.extension_,
    required this.randomPresetOrder,
  });
}

class PTZPresetTourStartingConditionExtension {}

@JsonSerializable()
class PTZPresetTourOptions {
  /// Indicates whether or not the AutoStart is supported.
  @JsonKey(name: 'AutoStart')
  final bool autoStart;

  /// Supported options for Preset Tour Starting Condition.
  @JsonKey(name: 'StartingCondition')
  final PTZPresetTourStartingConditionOptions startingCondition;

  /// Supported options for Preset Tour Spot.
  @JsonKey(name: 'TourSpot')
  final PTZPresetTourSpotOptions tourSpot;
  PTZPresetTourOptions({
    required this.autoStart,
    required this.startingCondition,
    required this.tourSpot,
  });
}

@JsonSerializable()
class PTZPresetTourSpotOptions {
  /// Supported options for detail definition of preset position of the tour spot.
  @JsonKey(name: 'PresetDetail')
  final PTZPresetTourPresetDetailOptions presetDetail;

  /// Supported range of stay time for a tour spot.
  @JsonKey(name: 'StayTime')
  final DurationRange stayTime;
  PTZPresetTourSpotOptions({
    required this.presetDetail,
    required this.stayTime,
  });
}

@JsonSerializable()
class PTZPresetTourPresetDetailOptions {
  /// A list of available Preset Tokens for tour spots.
  @JsonKey(name: 'PresetToken')
  final ReferenceToken? presetToken;

  /// An option to indicate Home postion for tour spots.
  @JsonKey(name: 'Home')
  final bool? home;

  /// Supported range of Pan and Tilt for tour spots.
  @JsonKey(name: 'PanTiltPositionSpace')
  final Space2DDescription? panTiltPositionSpace;

  /// Supported range of Zoom for a tour spot.
  @JsonKey(name: 'ZoomPositionSpace')
  final Space1DDescription? zoomPositionSpace;
  @JsonKey(name: 'Extension')
  final PTZPresetTourPresetDetailOptionsExtension? extension_;
  PTZPresetTourPresetDetailOptions({
    this.presetToken,
    this.home,
    this.panTiltPositionSpace,
    this.zoomPositionSpace,
    this.extension_,
  });
}

class PTZPresetTourPresetDetailOptionsExtension {}

@JsonSerializable()
class PTZPresetTourStartingConditionOptions {
  /// Supported range of Recurring Time.
  @JsonKey(name: 'RecurringTime')
  final IntRange? recurringTime;

  /// Supported range of Recurring Duration.
  @JsonKey(name: 'RecurringDuration')
  final DurationRange? recurringDuration;

  /// Supported options for Direction of Preset Tour.
  @JsonKey(name: 'Direction')
  final PTZPresetTourDirection? direction;
  @JsonKey(name: 'Extension')
  final PTZPresetTourStartingConditionOptionsExtension? extension_;
  PTZPresetTourStartingConditionOptions({
    this.recurringTime,
    this.recurringDuration,
    this.direction,
    this.extension_,
  });
}

class PTZPresetTourStartingConditionOptionsExtension {}

@JsonSerializable()
class ImagingStatus {
  @JsonKey(name: 'FocusStatus')
  final FocusStatus focusStatus;
  ImagingStatus({
    required this.focusStatus,
  });
}

@JsonSerializable()
class FocusStatus {
  ///
  /// Status of focus position.
  ///
  @JsonKey(name: 'Position')
  final double position;

  ///
  /// Status of focus MoveStatus.
  ///
  @JsonKey(name: 'MoveStatus')
  final MoveStatus moveStatus;

  ///
  /// Error status of focus.
  ///
  @JsonKey(name: 'Error')
  final String error;
  FocusStatus({
    required this.position,
    required this.moveStatus,
    required this.error,
  });
}

@JsonSerializable()
class FocusConfiguration {
  @JsonKey(name: 'AutoFocusMode')
  final AutoFocusMode autoFocusMode;
  @JsonKey(name: 'DefaultSpeed')
  final double defaultSpeed;

  /// Parameter to set autofocus near limit (unit: meter).
  @JsonKey(name: 'NearLimit')
  final double nearLimit;

  /// Parameter to set autofocus far limit (unit: meter).
  /// If set to 0.0, infinity will be used.
  @JsonKey(name: 'FarLimit')
  final double farLimit;
  FocusConfiguration({
    required this.autoFocusMode,
    required this.defaultSpeed,
    required this.nearLimit,
    required this.farLimit,
  });
}

enum AutoFocusMode {
  @JsonValue("AUTO")
  AUTO,
  @JsonValue("MANUAL")
  MANUAL,
}

enum AFModes {
  @JsonValue("OnceAfterMove")
  OnceAfterMove,
}

@JsonSerializable()
class ImagingSettings {
  /// Enabled/disabled BLC mode (on/off).
  @JsonKey(name: 'BacklightCompensation')
  final BacklightCompensation? backlightCompensation;

  /// Image brightness (unit unspecified).
  @JsonKey(name: 'Brightness')
  final double? brightness;

  /// Color saturation of the image (unit unspecified).
  @JsonKey(name: 'ColorSaturation')
  final double? colorSaturation;

  /// Contrast of the image (unit unspecified).
  @JsonKey(name: 'Contrast')
  final double? contrast;

  /// Exposure mode of the device.
  @JsonKey(name: 'Exposure')
  final Exposure? exposure;

  /// Focus configuration.
  @JsonKey(name: 'Focus')
  final FocusConfiguration? focus;

  /// Infrared Cutoff Filter settings.
  @JsonKey(name: 'IrCutFilter')
  final IrCutFilterMode? irCutFilter;

  /// Sharpness of the Video image.
  @JsonKey(name: 'Sharpness')
  final double? sharpness;

  /// WDR settings.
  @JsonKey(name: 'WideDynamicRange')
  final WideDynamicRange? wideDynamicRange;

  /// White balance settings.
  @JsonKey(name: 'WhiteBalance')
  final WhiteBalance? whiteBalance;
  @JsonKey(name: 'Extension')
  final ImagingSettingsExtension? extension_;
  ImagingSettings({
    this.backlightCompensation,
    this.brightness,
    this.colorSaturation,
    this.contrast,
    this.exposure,
    this.focus,
    this.irCutFilter,
    this.sharpness,
    this.wideDynamicRange,
    this.whiteBalance,
    this.extension_,
  });
}

class ImagingSettingsExtension {}

@JsonSerializable()
class Exposure {
  ///
  /// Exposure Mode
  ///
  /// Auto – Enabled the exposure algorithm on the NVT.
  /// Manual – Disabled exposure algorithm on the NVT.
  ///
  ///
  @JsonKey(name: 'Mode')
  final ExposureMode mode;

  ///
  /// The exposure priority mode (low noise/framerate).
  ///
  @JsonKey(name: 'Priority')
  final ExposurePriority priority;

  ///
  /// Rectangular exposure mask.
  ///
  @JsonKey(name: 'Window')
  final Rectangle window;

  ///
  /// Minimum value of exposure time range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MinExposureTime')
  final double minExposureTime;

  ///
  /// Maximum value of exposure time range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MaxExposureTime')
  final double maxExposureTime;

  ///
  /// Minimum value of the sensor gain range that is allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MinGain')
  final double minGain;

  ///
  /// Maximum value of the sensor gain range that is allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MaxGain')
  final double maxGain;

  ///
  /// Minimum value of the iris range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MinIris')
  final double minIris;

  ///
  /// Maximum value of the iris range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MaxIris')
  final double maxIris;

  ///
  /// The fixed exposure time used by the image sensor (μs).
  ///
  @JsonKey(name: 'ExposureTime')
  final double exposureTime;

  ///
  /// The fixed gain used by the image sensor (dB).
  ///
  @JsonKey(name: 'Gain')
  final double gain;

  ///
  /// The fixed attenuation of input light affected by the iris (dB). 0dB maps to a fully opened iris.
  ///
  @JsonKey(name: 'Iris')
  final double iris;
  Exposure({
    required this.mode,
    required this.priority,
    required this.window,
    required this.minExposureTime,
    required this.maxExposureTime,
    required this.minGain,
    required this.maxGain,
    required this.minIris,
    required this.maxIris,
    required this.exposureTime,
    required this.gain,
    required this.iris,
  });
}

enum WideDynamicMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
}

@JsonSerializable()
class WideDynamicRange {
  ///
  /// White dynamic range (on/off)
  ///
  @JsonKey(name: 'Mode')
  final WideDynamicMode mode;

  ///
  /// Optional level parameter (unitless)
  ///
  @JsonKey(name: 'Level')
  final double level;
  WideDynamicRange({
    required this.mode,
    required this.level,
  });
}

/// Enumeration describing the available backlight compenstation modes.
enum BacklightCompensationMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
}

@JsonSerializable()
class BacklightCompensation {
  /// Backlight compensation mode (on/off).
  @JsonKey(name: 'Mode')
  final BacklightCompensationMode mode;

  /// Optional level parameter (unit unspecified).
  @JsonKey(name: 'Level')
  final double level;
  BacklightCompensation({
    required this.mode,
    required this.level,
  });
}

enum ExposurePriority {
  @JsonValue("LowNoise")
  LowNoise,
  @JsonValue("FrameRate")
  FrameRate,
}

@JsonSerializable()
class ImagingOptions {
  @JsonKey(name: 'BacklightCompensation')
  final BacklightCompensationOptions backlightCompensation;
  @JsonKey(name: 'Brightness')
  final FloatRange brightness;
  @JsonKey(name: 'ColorSaturation')
  final FloatRange colorSaturation;
  @JsonKey(name: 'Contrast')
  final FloatRange contrast;
  @JsonKey(name: 'Exposure')
  final ExposureOptions exposure;
  @JsonKey(name: 'Focus')
  final FocusOptions focus;
  @JsonKey(name: 'IrCutFilterModes')
  final IrCutFilterMode irCutFilterModes;
  @JsonKey(name: 'Sharpness')
  final FloatRange sharpness;
  @JsonKey(name: 'WideDynamicRange')
  final WideDynamicRangeOptions wideDynamicRange;
  @JsonKey(name: 'WhiteBalance')
  final WhiteBalanceOptions whiteBalance;
  ImagingOptions({
    required this.backlightCompensation,
    required this.brightness,
    required this.colorSaturation,
    required this.contrast,
    required this.exposure,
    required this.focus,
    required this.irCutFilterModes,
    required this.sharpness,
    required this.wideDynamicRange,
    required this.whiteBalance,
  });
}

@JsonSerializable()
class WideDynamicRangeOptions {
  @JsonKey(name: 'Mode')
  final WideDynamicMode mode;
  @JsonKey(name: 'Level')
  final FloatRange level;
  WideDynamicRangeOptions({
    required this.mode,
    required this.level,
  });
}

@JsonSerializable()
class BacklightCompensationOptions {
  @JsonKey(name: 'Mode')
  final WideDynamicMode mode;
  @JsonKey(name: 'Level')
  final FloatRange level;
  BacklightCompensationOptions({
    required this.mode,
    required this.level,
  });
}

@JsonSerializable()
class FocusOptions {
  @JsonKey(name: 'AutoFocusModes')
  final AutoFocusMode? autoFocusModes;
  @JsonKey(name: 'DefaultSpeed')
  final FloatRange defaultSpeed;
  @JsonKey(name: 'NearLimit')
  final FloatRange nearLimit;
  @JsonKey(name: 'FarLimit')
  final FloatRange farLimit;
  FocusOptions({
    this.autoFocusModes,
    required this.defaultSpeed,
    required this.nearLimit,
    required this.farLimit,
  });
}

@JsonSerializable()
class ExposureOptions {
  @JsonKey(name: 'Mode')
  final ExposureMode mode;
  @JsonKey(name: 'Priority')
  final ExposurePriority priority;
  @JsonKey(name: 'MinExposureTime')
  final FloatRange minExposureTime;
  @JsonKey(name: 'MaxExposureTime')
  final FloatRange maxExposureTime;
  @JsonKey(name: 'MinGain')
  final FloatRange minGain;
  @JsonKey(name: 'MaxGain')
  final FloatRange maxGain;
  @JsonKey(name: 'MinIris')
  final FloatRange minIris;
  @JsonKey(name: 'MaxIris')
  final FloatRange maxIris;
  @JsonKey(name: 'ExposureTime')
  final FloatRange exposureTime;
  @JsonKey(name: 'Gain')
  final FloatRange gain;
  @JsonKey(name: 'Iris')
  final FloatRange iris;
  ExposureOptions({
    required this.mode,
    required this.priority,
    required this.minExposureTime,
    required this.maxExposureTime,
    required this.minGain,
    required this.maxGain,
    required this.minIris,
    required this.maxIris,
    required this.exposureTime,
    required this.gain,
    required this.iris,
  });
}

@JsonSerializable()
class WhiteBalanceOptions {
  @JsonKey(name: 'Mode')
  final WhiteBalanceMode mode;
  @JsonKey(name: 'YrGain')
  final FloatRange yrGain;
  @JsonKey(name: 'YbGain')
  final FloatRange ybGain;
  WhiteBalanceOptions({
    required this.mode,
    required this.yrGain,
    required this.ybGain,
  });
}

@JsonSerializable()
class FocusMove {
  ///
  /// Parameters for the absolute focus control.
  ///
  @JsonKey(name: 'Absolute')
  final AbsoluteFocus? absolute;

  ///
  /// Parameters for the relative focus control.
  ///
  @JsonKey(name: 'Relative')
  final RelativeFocus? relative;

  ///
  /// Parameter for the continuous focus control.
  ///
  @JsonKey(name: 'Continuous')
  final ContinuousFocus? continuous;
  FocusMove({
    this.absolute,
    this.relative,
    this.continuous,
  });
}

@JsonSerializable()
class AbsoluteFocus {
  ///
  /// Position parameter for the absolute focus control.
  ///
  @JsonKey(name: 'Position')
  final double position;

  ///
  /// Speed parameter for the absolute focus control.
  ///
  @JsonKey(name: 'Speed')
  final double? speed;
  AbsoluteFocus({
    required this.position,
    this.speed,
  });
}

@JsonSerializable()
class RelativeFocus {
  ///
  /// Distance parameter for the relative focus control.
  ///
  @JsonKey(name: 'Distance')
  final double distance;

  ///
  /// Speed parameter for the relative focus control.
  ///
  @JsonKey(name: 'Speed')
  final double? speed;
  RelativeFocus({
    required this.distance,
    this.speed,
  });
}

@JsonSerializable()
class ContinuousFocus {
  ///
  /// Speed parameter for the Continuous focus control.
  ///
  @JsonKey(name: 'Speed')
  final double speed;
  ContinuousFocus({
    required this.speed,
  });
}

@JsonSerializable()
class MoveOptions {
  @JsonKey(name: 'Absolute')
  final AbsoluteFocusOptions? absolute;
  @JsonKey(name: 'Relative')
  final RelativeFocusOptions? relative;
  @JsonKey(name: 'Continuous')
  final ContinuousFocusOptions? continuous;
  MoveOptions({
    this.absolute,
    this.relative,
    this.continuous,
  });
}

@JsonSerializable()
class AbsoluteFocusOptions {
  ///
  /// Valid ranges of the position.
  ///
  @JsonKey(name: 'Position')
  final FloatRange position;

  ///
  /// Valid ranges of the speed.
  ///
  @JsonKey(name: 'Speed')
  final FloatRange? speed;
  AbsoluteFocusOptions({
    required this.position,
    this.speed,
  });
}

@JsonSerializable()
class RelativeFocusOptions {
  ///
  /// Valid ranges of the distance.
  ///
  @JsonKey(name: 'Distance')
  final FloatRange distance;

  ///
  /// Valid ranges of the speed.
  ///
  @JsonKey(name: 'Speed')
  final FloatRange speed;
  RelativeFocusOptions({
    required this.distance,
    required this.speed,
  });
}

@JsonSerializable()
class ContinuousFocusOptions {
  ///
  /// Valid ranges of the speed.
  ///
  @JsonKey(name: 'Speed')
  final FloatRange speed;
  ContinuousFocusOptions({
    required this.speed,
  });
}

enum ExposureMode {
  @JsonValue("AUTO")
  AUTO,
  @JsonValue("MANUAL")
  MANUAL,
}

enum Enabled {
  @JsonValue("ENABLED")
  ENABLED,
  @JsonValue("DISABLED")
  DISABLED,
}

enum WhiteBalanceMode {
  @JsonValue("AUTO")
  AUTO,
  @JsonValue("MANUAL")
  MANUAL,
}

enum IrCutFilterMode {
  @JsonValue("ON")
  ON_,
  @JsonValue("OFF")
  OFF,
  @JsonValue("AUTO")
  AUTO,
}

@JsonSerializable()
class WhiteBalance {
  /// Auto whitebalancing mode (auto/manual).
  @JsonKey(name: 'Mode')
  final WhiteBalanceMode mode;

  /// Rgain (unitless).
  @JsonKey(name: 'CrGain')
  final double crGain;

  /// Bgain (unitless).
  @JsonKey(name: 'CbGain')
  final double cbGain;
  WhiteBalance({
    required this.mode,
    required this.crGain,
    required this.cbGain,
  });
}

@JsonSerializable()
class ImagingStatus20 {
  ///
  /// Status of focus.
  ///
  @JsonKey(name: 'FocusStatus20')
  final FocusStatus20? focusStatus20;
  @JsonKey(name: 'Extension')
  final ImagingStatus20Extension? extension_;
  ImagingStatus20({
    this.focusStatus20,
    this.extension_,
  });
}

class ImagingStatus20Extension {}

@JsonSerializable()
class FocusStatus20 {
  ///
  /// Status of focus position.
  ///
  @JsonKey(name: 'Position')
  final double position;

  ///
  /// Status of focus MoveStatus.
  ///
  @JsonKey(name: 'MoveStatus')
  final MoveStatus moveStatus;

  ///
  /// Error status of focus.
  ///
  @JsonKey(name: 'Error')
  final String? error;
  @JsonKey(name: 'Extension')
  final FocusStatus20Extension? extension_;
  FocusStatus20({
    required this.position,
    required this.moveStatus,
    this.error,
    this.extension_,
  });
}

class FocusStatus20Extension {}

/// Type describing the ImagingSettings of a VideoSource. The supported options and ranges can be obtained via the GetOptions command.
@JsonSerializable()
class ImagingSettings20 {
  /// Enabled/disabled BLC mode (on/off).
  @JsonKey(name: 'BacklightCompensation')
  final BacklightCompensation20? backlightCompensation;

  /// Image brightness (unit unspecified).
  @JsonKey(name: 'Brightness')
  final double? brightness;

  /// Color saturation of the image (unit unspecified).
  @JsonKey(name: 'ColorSaturation')
  final double? colorSaturation;

  /// Contrast of the image (unit unspecified).
  @JsonKey(name: 'Contrast')
  final double? contrast;

  /// Exposure mode of the device.
  @JsonKey(name: 'Exposure')
  final Exposure20? exposure;

  /// Focus configuration.
  @JsonKey(name: 'Focus')
  final FocusConfiguration20? focus;

  /// Infrared Cutoff Filter settings.
  @JsonKey(name: 'IrCutFilter')
  final IrCutFilterMode? irCutFilter;

  /// Sharpness of the Video image.
  @JsonKey(name: 'Sharpness')
  final double? sharpness;

  /// WDR settings.
  @JsonKey(name: 'WideDynamicRange')
  final WideDynamicRange20? wideDynamicRange;

  /// White balance settings.
  @JsonKey(name: 'WhiteBalance')
  final WhiteBalance20? whiteBalance;
  @JsonKey(name: 'Extension')
  final ImagingSettingsExtension20? extension_;
  ImagingSettings20({
    this.backlightCompensation,
    this.brightness,
    this.colorSaturation,
    this.contrast,
    this.exposure,
    this.focus,
    this.irCutFilter,
    this.sharpness,
    this.wideDynamicRange,
    this.whiteBalance,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingSettingsExtension20 {
  /// Optional element to configure Image Stabilization feature.
  @JsonKey(name: 'ImageStabilization')
  final ImageStabilization? imageStabilization;
  @JsonKey(name: 'Extension')
  final ImagingSettingsExtension202? extension_;
  ImagingSettingsExtension20({
    this.imageStabilization,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingSettingsExtension202 {
  /// An optional parameter applied to only auto mode to adjust timing of toggling Ir cut filter.
  @JsonKey(name: 'IrCutFilterAutoAdjustment')
  final IrCutFilterAutoAdjustment? irCutFilterAutoAdjustment;
  @JsonKey(name: 'Extension')
  final ImagingSettingsExtension203? extension_;
  ImagingSettingsExtension202({
    this.irCutFilterAutoAdjustment,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingSettingsExtension203 {
  /// Optional element to configure Image Contrast Compensation.
  @JsonKey(name: 'ToneCompensation')
  final ToneCompensation? toneCompensation;

  /// Optional element to configure Image Defogging.
  @JsonKey(name: 'Defogging')
  final Defogging? defogging;

  /// Optional element to configure Image Noise Reduction.
  @JsonKey(name: 'NoiseReduction')
  final NoiseReduction? noiseReduction;
  @JsonKey(name: 'Extension')
  final ImagingSettingsExtension204? extension_;
  ImagingSettingsExtension203({
    this.toneCompensation,
    this.defogging,
    this.noiseReduction,
    this.extension_,
  });
}

class ImagingSettingsExtension204 {}

@JsonSerializable()
class ImageStabilization {
  /// Parameter to enable/disable Image Stabilization feature.
  @JsonKey(name: 'Mode')
  final ImageStabilizationMode mode;

  /// Optional level parameter (unit unspecified)
  @JsonKey(name: 'Level')
  final double? level;
  @JsonKey(name: 'Extension')
  final ImageStabilizationExtension? extension_;
  ImageStabilization({
    required this.mode,
    this.level,
    this.extension_,
  });
}

class ImageStabilizationExtension {}

enum ImageStabilizationMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("AUTO")
  AUTO,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class IrCutFilterAutoAdjustment {
  /// Specifies which boundaries to automatically toggle Ir cut filter following parameters are applied to. Its options shall be chosen from tt:IrCutFilterAutoBoundaryType.
  @JsonKey(name: 'BoundaryType')
  final String boundaryType;

  /// Adjusts boundary exposure level for toggling Ir cut filter to on/off specified with unitless normalized value from +1.0 to -1.0. Zero is default and -1.0 is the darkest adjustment (Unitless).
  @JsonKey(name: 'BoundaryOffset')
  final double? boundaryOffset;

  /// Delay time of toggling Ir cut filter to on/off after crossing of the boundary exposure levels.
  @JsonKey(name: 'ResponseTime')
  final Duration? responseTime;
  @JsonKey(name: 'Extension')
  final IrCutFilterAutoAdjustmentExtension? extension_;
  IrCutFilterAutoAdjustment({
    required this.boundaryType,
    this.boundaryOffset,
    this.responseTime,
    this.extension_,
  });
}

class IrCutFilterAutoAdjustmentExtension {}

enum IrCutFilterAutoBoundaryType {
  @JsonValue("Common")
  Common,
  @JsonValue("ToOn")
  ToOn,
  @JsonValue("ToOff")
  ToOff,
  @JsonValue("Extended")
  Extended,
}

/// Type describing whether WDR mode is enabled or disabled (on/off).
@JsonSerializable()
class WideDynamicRange20 {
  /// Wide dynamic range mode (on/off).
  @JsonKey(name: 'Mode')
  final WideDynamicMode mode;

  /// Optional level parameter (unit unspecified).
  @JsonKey(name: 'Level')
  final double? level;
  WideDynamicRange20({
    required this.mode,
    this.level,
  });
}

/// Type describing whether BLC mode is enabled or disabled (on/off).
@JsonSerializable()
class BacklightCompensation20 {
  /// Backlight compensation mode (on/off).
  @JsonKey(name: 'Mode')
  final BacklightCompensationMode mode;

  /// Optional level parameter (unit unspecified).
  @JsonKey(name: 'Level')
  final double? level;
  BacklightCompensation20({
    required this.mode,
    this.level,
  });
}

/// Type describing the exposure settings.
@JsonSerializable()
class Exposure20 {
  ///
  /// Exposure Mode
  ///
  /// Auto – Enabled the exposure algorithm on the device.
  /// Manual – Disabled exposure algorithm on the device.
  ///
  ///
  @JsonKey(name: 'Mode')
  final ExposureMode mode;

  ///
  /// The exposure priority mode (low noise/framerate).
  ///
  @JsonKey(name: 'Priority')
  final ExposurePriority? priority;

  ///
  /// Rectangular exposure mask.
  ///
  @JsonKey(name: 'Window')
  final Rectangle? window;

  ///
  /// Minimum value of exposure time range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MinExposureTime')
  final double? minExposureTime;

  ///
  /// Maximum value of exposure time range allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MaxExposureTime')
  final double? maxExposureTime;

  ///
  /// Minimum value of the sensor gain range that is allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MinGain')
  final double? minGain;

  ///
  /// Maximum value of the sensor gain range that is allowed to be used by the algorithm.
  ///
  @JsonKey(name: 'MaxGain')
  final double? maxGain;

  ///
  /// Minimum value of the iris range allowed to be used by the algorithm.  0dB maps to a fully opened iris and positive values map to higher attenuation.
  ///
  @JsonKey(name: 'MinIris')
  final double? minIris;

  ///
  /// Maximum value of the iris range allowed to be used by the algorithm. 0dB maps to a fully opened iris and positive values map to higher attenuation.
  ///
  @JsonKey(name: 'MaxIris')
  final double? maxIris;

  ///
  /// The fixed exposure time used by the image sensor (μs).
  ///
  @JsonKey(name: 'ExposureTime')
  final double? exposureTime;

  ///
  /// The fixed gain used by the image sensor (dB).
  ///
  @JsonKey(name: 'Gain')
  final double? gain;

  ///
  /// The fixed attenuation of input light affected by the iris (dB). 0dB maps to a fully opened iris and positive values map to higher attenuation.
  ///
  @JsonKey(name: 'Iris')
  final double? iris;
  Exposure20({
    required this.mode,
    this.priority,
    this.window,
    this.minExposureTime,
    this.maxExposureTime,
    this.minGain,
    this.maxGain,
    this.minIris,
    this.maxIris,
    this.exposureTime,
    this.gain,
    this.iris,
  });
}

@JsonSerializable()
class ToneCompensation {
  /// Parameter to enable/disable or automatic ToneCompensation feature. Its options shall be chosen from tt:ToneCompensationMode Type.
  @JsonKey(name: 'Mode')
  final String mode;

  /// Optional level parameter specified with unitless normalized value from 0.0 to +1.0.
  @JsonKey(name: 'Level')
  final double? level;
  @JsonKey(name: 'Extension')
  final ToneCompensationExtension? extension_;
  ToneCompensation({
    required this.mode,
    this.level,
    this.extension_,
  });
}

class ToneCompensationExtension {}

enum ToneCompensationMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("AUTO")
  AUTO,
}

@JsonSerializable()
class Defogging {
  /// Parameter to enable/disable or automatic Defogging feature. Its options shall be chosen from tt:DefoggingMode Type.
  @JsonKey(name: 'Mode')
  final String mode;

  /// Optional level parameter specified with unitless normalized value from 0.0 to +1.0.
  @JsonKey(name: 'Level')
  final double? level;
  @JsonKey(name: 'Extension')
  final DefoggingExtension? extension_;
  Defogging({
    required this.mode,
    this.level,
    this.extension_,
  });
}

class DefoggingExtension {}

enum DefoggingMode {
  @JsonValue("OFF")
  OFF,
  @JsonValue("ON")
  ON_,
  @JsonValue("AUTO")
  AUTO,
}

@JsonSerializable()
class NoiseReduction {
  /// Level parameter specified with unitless normalized value from 0.0 to +1.0. Level=0 means no noise reduction or minimal noise reduction.
  @JsonKey(name: 'Level')
  final double level;
  NoiseReduction({
    required this.level,
  });
}

@JsonSerializable()
class ImagingOptions20 {
  ///
  /// Valid range of Backlight Compensation.
  ///
  @JsonKey(name: 'BacklightCompensation')
  final BacklightCompensationOptions20? backlightCompensation;

  ///
  /// Valid range of Brightness.
  ///
  @JsonKey(name: 'Brightness')
  final FloatRange? brightness;

  ///
  /// Valid range of Color Saturation.
  ///
  @JsonKey(name: 'ColorSaturation')
  final FloatRange? colorSaturation;

  ///
  /// Valid range of Contrast.
  ///
  @JsonKey(name: 'Contrast')
  final FloatRange? contrast;

  ///
  /// Valid range of Exposure.
  ///
  @JsonKey(name: 'Exposure')
  final ExposureOptions20? exposure;

  ///
  /// Valid range of Focus.
  ///
  @JsonKey(name: 'Focus')
  final FocusOptions20? focus;

  ///
  /// Valid range of IrCutFilterModes.
  ///
  @JsonKey(name: 'IrCutFilterModes')
  final IrCutFilterMode? irCutFilterModes;

  ///
  /// Valid range of Sharpness.
  ///
  @JsonKey(name: 'Sharpness')
  final FloatRange? sharpness;

  ///
  /// Valid range of WideDynamicRange.
  ///
  @JsonKey(name: 'WideDynamicRange')
  final WideDynamicRangeOptions20? wideDynamicRange;

  ///
  /// Valid range of WhiteBalance.
  ///
  @JsonKey(name: 'WhiteBalance')
  final WhiteBalanceOptions20? whiteBalance;
  @JsonKey(name: 'Extension')
  final ImagingOptions20Extension? extension_;
  ImagingOptions20({
    this.backlightCompensation,
    this.brightness,
    this.colorSaturation,
    this.contrast,
    this.exposure,
    this.focus,
    this.irCutFilterModes,
    this.sharpness,
    this.wideDynamicRange,
    this.whiteBalance,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingOptions20Extension {
  /// Options of parameters for Image Stabilization feature.
  @JsonKey(name: 'ImageStabilization')
  final ImageStabilizationOptions? imageStabilization;
  @JsonKey(name: 'Extension')
  final ImagingOptions20Extension2? extension_;
  ImagingOptions20Extension({
    this.imageStabilization,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingOptions20Extension2 {
  /// Options of parameters for adjustment of Ir cut filter auto mode.
  @JsonKey(name: 'IrCutFilterAutoAdjustment')
  final IrCutFilterAutoAdjustmentOptions? irCutFilterAutoAdjustment;
  @JsonKey(name: 'Extension')
  final ImagingOptions20Extension3? extension_;
  ImagingOptions20Extension2({
    this.irCutFilterAutoAdjustment,
    this.extension_,
  });
}

@JsonSerializable()
class ImagingOptions20Extension3 {
  /// Options of parameters for Tone Compensation feature.
  @JsonKey(name: 'ToneCompensationOptions')
  final ToneCompensationOptions? toneCompensationOptions;

  /// Options of parameters for Defogging feature.
  @JsonKey(name: 'DefoggingOptions')
  final DefoggingOptions? defoggingOptions;

  /// Options of parameter for Noise Reduction feature.
  @JsonKey(name: 'NoiseReductionOptions')
  final NoiseReductionOptions? noiseReductionOptions;
  @JsonKey(name: 'Extension')
  final ImagingOptions20Extension4? extension_;
  ImagingOptions20Extension3({
    this.toneCompensationOptions,
    this.defoggingOptions,
    this.noiseReductionOptions,
    this.extension_,
  });
}

class ImagingOptions20Extension4 {}

@JsonSerializable()
class ImageStabilizationOptions {
  /// Supported options of Image Stabilization mode parameter.
  @JsonKey(name: 'Mode')
  final ImageStabilizationMode mode;

  /// Valid range of the Image Stabilization.
  @JsonKey(name: 'Level')
  final FloatRange? level;
  @JsonKey(name: 'Extension')
  final ImageStabilizationOptionsExtension? extension_;
  ImageStabilizationOptions({
    required this.mode,
    this.level,
    this.extension_,
  });
}

class ImageStabilizationOptionsExtension {}

@JsonSerializable()
class IrCutFilterAutoAdjustmentOptions {
  /// Supported options of boundary types for adjustment of Ir cut filter auto mode. The opptions shall be chosen from tt:IrCutFilterAutoBoundaryType.
  @JsonKey(name: 'BoundaryType')
  final String boundaryType;

  /// Indicates whether or not boundary offset for toggling Ir cut filter is supported.
  @JsonKey(name: 'BoundaryOffset')
  final bool? boundaryOffset;

  /// Supported range of delay time for toggling Ir cut filter.
  @JsonKey(name: 'ResponseTimeRange')
  final DurationRange? responseTimeRange;
  @JsonKey(name: 'Extension')
  final IrCutFilterAutoAdjustmentOptionsExtension? extension_;
  IrCutFilterAutoAdjustmentOptions({
    required this.boundaryType,
    this.boundaryOffset,
    this.responseTimeRange,
    this.extension_,
  });
}

class IrCutFilterAutoAdjustmentOptionsExtension {}

@JsonSerializable()
class WideDynamicRangeOptions20 {
  @JsonKey(name: 'Mode')
  final WideDynamicMode mode;
  @JsonKey(name: 'Level')
  final FloatRange? level;
  WideDynamicRangeOptions20({
    required this.mode,
    this.level,
  });
}

@JsonSerializable()
class BacklightCompensationOptions20 {
  ///
  /// 'ON' or 'OFF'
  ///
  @JsonKey(name: 'Mode')
  final BacklightCompensationMode mode;

  ///
  /// Level range of BacklightCompensation.
  ///
  @JsonKey(name: 'Level')
  final FloatRange? level;
  BacklightCompensationOptions20({
    required this.mode,
    this.level,
  });
}

@JsonSerializable()
class ExposureOptions20 {
  ///
  /// Exposure Mode
  ///
  /// Auto – Enabled the exposure algorithm on the device.
  /// Manual – Disabled exposure algorithm on the device.
  ///
  ///
  @JsonKey(name: 'Mode')
  final ExposureMode mode;

  ///
  /// The exposure priority mode (low noise/framerate).
  ///
  @JsonKey(name: 'Priority')
  final ExposurePriority? priority;

  ///
  /// Valid range of the Minimum ExposureTime.
  ///
  @JsonKey(name: 'MinExposureTime')
  final FloatRange? minExposureTime;

  ///
  /// Valid range of the Maximum ExposureTime.
  ///
  @JsonKey(name: 'MaxExposureTime')
  final FloatRange? maxExposureTime;

  ///
  /// Valid range of the Minimum Gain.
  ///
  @JsonKey(name: 'MinGain')
  final FloatRange? minGain;

  ///
  /// Valid range of the Maximum Gain.
  ///
  @JsonKey(name: 'MaxGain')
  final FloatRange? maxGain;

  ///
  /// Valid range of the Minimum Iris.
  ///
  @JsonKey(name: 'MinIris')
  final FloatRange? minIris;

  ///
  /// Valid range of the Maximum Iris.
  ///
  @JsonKey(name: 'MaxIris')
  final FloatRange? maxIris;

  ///
  /// Valid range of the ExposureTime.
  ///
  @JsonKey(name: 'ExposureTime')
  final FloatRange? exposureTime;

  ///
  /// Valid range of the Gain.
  ///
  @JsonKey(name: 'Gain')
  final FloatRange? gain;

  ///
  /// Valid range of the Iris.
  ///
  @JsonKey(name: 'Iris')
  final FloatRange? iris;
  ExposureOptions20({
    required this.mode,
    this.priority,
    this.minExposureTime,
    this.maxExposureTime,
    this.minGain,
    this.maxGain,
    this.minIris,
    this.maxIris,
    this.exposureTime,
    this.gain,
    this.iris,
  });
}

@JsonSerializable()
class MoveOptions20 {
  ///
  /// Valid ranges for the absolute control.
  ///
  @JsonKey(name: 'Absolute')
  final AbsoluteFocusOptions? absolute;

  ///
  /// Valid ranges for the relative control.
  ///
  @JsonKey(name: 'Relative')
  final RelativeFocusOptions20? relative;

  ///
  /// Valid ranges for the continuous control.
  ///
  @JsonKey(name: 'Continuous')
  final ContinuousFocusOptions? continuous;
  MoveOptions20({
    this.absolute,
    this.relative,
    this.continuous,
  });
}

@JsonSerializable()
class RelativeFocusOptions20 {
  ///
  /// Valid ranges of the distance.
  ///
  @JsonKey(name: 'Distance')
  final FloatRange distance;

  ///
  /// Valid ranges of the speed.
  ///
  @JsonKey(name: 'Speed')
  final FloatRange? speed;
  RelativeFocusOptions20({
    required this.distance,
    this.speed,
  });
}

@JsonSerializable()
class WhiteBalance20 {
  ///
  /// 'AUTO' or 'MANUAL'
  ///
  @JsonKey(name: 'Mode')
  final WhiteBalanceMode mode;

  ///
  /// Rgain (unitless).
  ///
  @JsonKey(name: 'CrGain')
  final double? crGain;

  ///
  /// Bgain (unitless).
  ///
  @JsonKey(name: 'CbGain')
  final double? cbGain;
  @JsonKey(name: 'Extension')
  final WhiteBalance20Extension? extension_;
  WhiteBalance20({
    required this.mode,
    this.crGain,
    this.cbGain,
    this.extension_,
  });
}

class WhiteBalance20Extension {}

@JsonSerializable()
class FocusConfiguration20 {
  ///
  /// Mode of auto focus.
  ///
  /// AUTO - The device automatically adjusts focus.
  /// MANUAL - The device does not automatically adjust focus.
  ///
  /// Note: for devices supporting both manual and auto operation at the same time manual operation may be supported even if the Mode parameter is set to Auto.
  ///
  @JsonKey(name: 'AutoFocusMode')
  final AutoFocusMode autoFocusMode;
  @JsonKey(name: 'DefaultSpeed')
  final double? defaultSpeed;

  /// Parameter to set autofocus near limit (unit: meter).
  @JsonKey(name: 'NearLimit')
  final double? nearLimit;

  /// Parameter to set autofocus far limit (unit: meter).
  @JsonKey(name: 'FarLimit')
  final double? farLimit;
  @JsonKey(name: 'Extension')
  final FocusConfiguration20Extension? extension_;

  /// Zero or more modes as defined in enumeration tt:AFModes.
  @JsonKey(name: 'AFMode')
  final StringAttrList aFMode;
  FocusConfiguration20({
    required this.autoFocusMode,
    this.defaultSpeed,
    this.nearLimit,
    this.farLimit,
    this.extension_,
    required this.aFMode,
  });
}

class FocusConfiguration20Extension {}

@JsonSerializable()
class WhiteBalanceOptions20 {
  ///
  /// Mode of WhiteBalance.
  ///
  /// AUTO
  /// MANUAL
  ///
  ///
  @JsonKey(name: 'Mode')
  final WhiteBalanceMode mode;
  @JsonKey(name: 'YrGain')
  final FloatRange? yrGain;
  @JsonKey(name: 'YbGain')
  final FloatRange? ybGain;
  @JsonKey(name: 'Extension')
  final WhiteBalanceOptions20Extension? extension_;
  WhiteBalanceOptions20({
    required this.mode,
    this.yrGain,
    this.ybGain,
    this.extension_,
  });
}

class WhiteBalanceOptions20Extension {}

@JsonSerializable()
class FocusOptions20 {
  ///
  /// Supported modes for auto focus.
  ///
  /// AUTO - The device supports automatic focus adjustment.
  /// MANUAL - The device supports manual focus adjustment.
  ///
  ///
  @JsonKey(name: 'AutoFocusModes')
  final AutoFocusMode? autoFocusModes;

  ///
  /// Valid range of DefaultSpeed.
  ///
  @JsonKey(name: 'DefaultSpeed')
  final FloatRange? defaultSpeed;

  ///
  /// Valid range of NearLimit.
  ///
  @JsonKey(name: 'NearLimit')
  final FloatRange? nearLimit;

  ///
  /// Valid range of FarLimit.
  ///
  @JsonKey(name: 'FarLimit')
  final FloatRange? farLimit;
  @JsonKey(name: 'Extension')
  final FocusOptions20Extension? extension_;
  FocusOptions20({
    this.autoFocusModes,
    this.defaultSpeed,
    this.nearLimit,
    this.farLimit,
    this.extension_,
  });
}

@JsonSerializable()
class FocusOptions20Extension {
  /// Supported options for auto focus. Options shall be chosen from tt:AFModes.
  @JsonKey(name: 'AFModes')
  final StringAttrList? aFModes;
  FocusOptions20Extension({
    this.aFModes,
  });
}

@JsonSerializable()
class ToneCompensationOptions {
  /// Supported options for Tone Compensation mode. Its options shall be chosen from tt:ToneCompensationMode Type.
  @JsonKey(name: 'Mode')
  final String mode;

  /// Indicates whether or not support Level parameter for Tone Compensation.
  @JsonKey(name: 'Level')
  final bool level;
  ToneCompensationOptions({
    required this.mode,
    required this.level,
  });
}

@JsonSerializable()
class DefoggingOptions {
  /// Supported options for Defogging mode. Its options shall be chosen from tt:DefoggingMode Type.
  @JsonKey(name: 'Mode')
  final String mode;

  /// Indicates whether or not support Level parameter for Defogging.
  @JsonKey(name: 'Level')
  final bool level;
  DefoggingOptions({
    required this.mode,
    required this.level,
  });
}

@JsonSerializable()
class NoiseReductionOptions {
  /// Indicates whether or not support Level parameter for NoiseReduction.
  @JsonKey(name: 'Level')
  final bool level;
  NoiseReductionOptions({
    required this.level,
  });
}

@JsonSerializable()
class TopicNamespaceLocation {
  @JsonKey(name: 'val')
  final String val;
  TopicNamespaceLocation({
    required this.val,
  });
}

enum PropertyOperation {
  @JsonValue("Initialized")
  Initialized,
  @JsonValue("Deleted")
  Deleted,
  @JsonValue("Changed")
  Changed,
}

@JsonSerializable()
class Message {
  /// Token value pairs that triggered this message. Typically only one item is present.
  @JsonKey(name: 'Source')
  final ItemList? source;
  @JsonKey(name: 'Key')
  final ItemList? key;
  @JsonKey(name: 'Data')
  final ItemList? data;
  @JsonKey(name: 'Extension')
  final MessageExtension? extension_;
  Message({
    this.source,
    this.key,
    this.data,
    this.extension_,
  });
}

class MessageExtension {}

///
/// List of parameters according to the corresponding ItemListDescription.
/// Each item in the list shall have a unique name.
///
@JsonSerializable()
class ItemList {
  @JsonKey(name: 'Extension')
  final ItemListExtension? extension_;
  ItemList({
    this.extension_,
  });
}

class ItemListExtension {}

@JsonSerializable()
class MessageDescription {
  /// Set of tokens producing this message. The list may only contain SimpleItemDescription items.
  /// The set of tokens identify the component within the WS-Endpoint, which is responsible for the producing the message.
  /// For analytics events the token set shall include the VideoSourceConfigurationToken, the VideoAnalyticsConfigurationToken
  /// and the name of the analytics module or rule.
  ///
  @JsonKey(name: 'Source')
  final ItemListDescription? source;

  /// Describes optional message payload parameters that may be used as key. E.g. object IDs of tracked objects are conveyed as key.
  @JsonKey(name: 'Key')
  final ItemListDescription? key;

  /// Describes the payload of the message.
  @JsonKey(name: 'Data')
  final ItemListDescription? data;
  @JsonKey(name: 'Extension')
  final MessageDescriptionExtension? extension_;

  /// Must be set to true when the described Message relates to a property. An alternative term of "property" is a "state" in contrast to a pure event, which contains relevant information for only a single point in time.Default is false.
  @JsonKey(name: 'IsProperty')
  final bool isProperty;
  MessageDescription({
    this.source,
    this.key,
    this.data,
    this.extension_,
    required this.isProperty,
  });
}

class MessageDescriptionExtension {}

///
/// Describes a list of items. Each item in the list shall have a unique name.
/// The list is designed as linear structure without optional or unbounded elements.
/// Use ElementItems only when complex structures are inevitable.
///
@JsonSerializable()
class ItemListDescription {
  @JsonKey(name: 'Extension')
  final ItemListDescriptionExtension? extension_;
  ItemListDescription({
    this.extension_,
  });
}

class ItemListDescriptionExtension {}

@JsonSerializable()
class Polyline {
  @JsonKey(name: 'Point')
  final Vector point;
  Polyline({
    required this.point,
  });
}

enum Direction {
  @JsonValue("Left")
  Left,
  @JsonValue("Right")
  Right,
  @JsonValue("Any")
  Any,
}

@JsonSerializable()
class AnalyticsEngineConfiguration {
  @JsonKey(name: 'AnalyticsModule')
  final Config? analyticsModule;
  @JsonKey(name: 'Extension')
  final AnalyticsEngineConfigurationExtension? extension_;
  AnalyticsEngineConfiguration({
    this.analyticsModule,
    this.extension_,
  });
}

class AnalyticsEngineConfigurationExtension {}

@JsonSerializable()
class RuleEngineConfiguration {
  @JsonKey(name: 'Rule')
  final Config? rule;
  @JsonKey(name: 'Extension')
  final RuleEngineConfigurationExtension? extension_;
  RuleEngineConfiguration({
    this.rule,
    this.extension_,
  });
}

class RuleEngineConfigurationExtension {}

@JsonSerializable()
class Config {
  /// List of configuration parameters as defined in the correspding description.
  @JsonKey(name: 'Parameters')
  final ItemList parameters;

  /// Name of the configuration.
  @JsonKey(name: 'Name')
  final String name;

  /// The Type attribute specifies the type of rule and shall be equal to value of one of Name attributes of ConfigDescription elements returned by GetSupportedRules and GetSupportedAnalyticsModules command.
  @JsonKey(name: 'Type')
  final String type;
  Config({
    required this.parameters,
    required this.name,
    required this.type,
  });
}

@JsonSerializable()
class ConfigDescription extends MessageDescription {
  ///
  /// List describing the configuration parameters. The names of the parameters must be unique. If possible SimpleItems
  /// should be used to transport the information to ease parsing of dynamically defined messages by a client
  /// application.
  ///
  @JsonKey(name: 'Parameters')
  final ItemListDescription parameters;
  @JsonKey(name: 'Extension_inner')
  final ConfigDescriptionExtension? extension_inner;

  /// The Name attribute (e.g. "tt::LineDetector") uniquely identifies the type of rule, not a type definition in a schema.
  @JsonKey(name: 'Name')
  final String name;

  /// The fixed attribute signals that it is not allowed to add or remove this type of configuration.
  @JsonKey(name: 'fixed')
  final bool fixed;

  /// The maxInstances attribute signals the maximum number of instances per configuration.
  @JsonKey(name: 'maxInstances')
  final int maxInstances;
  ConfigDescription({
    required this.parameters,
    this.extension_inner,
    required this.name,
    required this.fixed,
    required this.maxInstances,
    super.source,
    super.key,
    super.data,
    super.extension_,
    required super.isProperty,
  });
}

class ConfigDescriptionExtension {}

@JsonSerializable()
class SupportedRules {
  /// Lists the location of all schemas that are referenced in the rules.
  @JsonKey(name: 'RuleContentSchemaLocation')
  final String? ruleContentSchemaLocation;

  /// List of rules supported by the Video Analytics configuration..
  @JsonKey(name: 'RuleDescription')
  final ConfigDescription? ruleDescription;
  @JsonKey(name: 'Extension')
  final SupportedRulesExtension? extension_;
  SupportedRules({
    this.ruleContentSchemaLocation,
    this.ruleDescription,
    this.extension_,
  });
}

class SupportedRulesExtension {}

@JsonSerializable()
class SupportedAnalyticsModules {
  /// It optionally contains a list of URLs that provide the location of schema files.
  /// These schema files describe the types and elements used in the analytics module descriptions.
  /// Analytics module descriptions that reference types or elements imported from any ONVIF defined schema files
  /// need not explicitly list those schema files.
  @JsonKey(name: 'AnalyticsModuleContentSchemaLocation')
  final String? analyticsModuleContentSchemaLocation;
  @JsonKey(name: 'AnalyticsModuleDescription')
  final ConfigDescription? analyticsModuleDescription;
  @JsonKey(name: 'Extension')
  final SupportedAnalyticsModulesExtension? extension_;
  SupportedAnalyticsModules({
    this.analyticsModuleContentSchemaLocation,
    this.analyticsModuleDescription,
    this.extension_,
  });
}

class SupportedAnalyticsModulesExtension {}

@JsonSerializable()
class PolygonConfiguration {
  /// Contains Polygon configuration for rule parameters
  @JsonKey(name: 'Polygon')
  final Polygon polygon;
  PolygonConfiguration({
    required this.polygon,
  });
}

@JsonSerializable()
class PolylineArray {
  /// Contains array of Polyline
  @JsonKey(name: 'Segment')
  final Polyline segment;
  @JsonKey(name: 'Extension')
  final PolylineArrayExtension? extension_;
  PolylineArray({
    required this.segment,
    this.extension_,
  });
}

class PolylineArrayExtension {}

@JsonSerializable()
class PolylineArrayConfiguration {
  /// Contains PolylineArray configuration data
  @JsonKey(name: 'PolylineArray')
  final PolylineArray polylineArray;
  PolylineArrayConfiguration({
    required this.polylineArray,
  });
}

@JsonSerializable()
class MotionExpression {
  /// Motion Expression data structure contains motion expression which is based on Scene Descriptor schema with XPATH syntax. The Type argument could allow introduction of different dialects
  @JsonKey(name: 'Expression')
  final String expression;
  @JsonKey(name: 'Type')
  final String type;
  MotionExpression({
    required this.expression,
    required this.type,
  });
}

@JsonSerializable()
class MotionExpressionConfiguration {
  /// Contains Rule MotionExpression configuration
  @JsonKey(name: 'MotionExpression')
  final MotionExpression motionExpression;
  MotionExpressionConfiguration({
    required this.motionExpression,
  });
}

@JsonSerializable()
class CellLayout {
  /// Mapping of the cell grid to the Video frame. The cell grid is starting from the upper left corner and x dimension is going from left to right and the y dimension from up to down.
  @JsonKey(name: 'Transformation')
  final Transformation transformation;

  /// Number of columns of the cell grid (x dimension)
  @JsonKey(name: 'Columns')
  final int columns;

  /// Number of rows of the cell grid (y dimension)
  @JsonKey(name: 'Rows')
  final int rows;
  CellLayout({
    required this.transformation,
    required this.columns,
    required this.rows,
  });
}

/// Configuration of the streaming and coding settings of a Video window.
@JsonSerializable()
class PaneConfiguration {
  /// Optional name of the pane configuration.
  @JsonKey(name: 'PaneName')
  final String? paneName;

  /// If the device has audio outputs, this element contains a pointer to the audio output that is associated with the pane. A client
  /// can retrieve the available audio outputs of a device using the GetAudioOutputs command of the DeviceIO service.
  @JsonKey(name: 'AudioOutputToken')
  final ReferenceToken? audioOutputToken;

  /// If the device has audio sources, this element contains a pointer to the audio source that is associated with this pane.
  /// The audio connection from a decoder device to the NVT is established using the backchannel mechanism. A client can retrieve the available audio sources of a device using the GetAudioSources command of the
  /// DeviceIO service.
  @JsonKey(name: 'AudioSourceToken')
  final ReferenceToken? audioSourceToken;

  /// The configuration of the audio encoder including codec, bitrate
  /// and sample rate.
  @JsonKey(name: 'AudioEncoderConfiguration')
  final AudioEncoderConfiguration? audioEncoderConfiguration;

  /// A pointer to a Receiver that has the necessary information to receive
  /// data from a Transmitter. This Receiver can be connected and the network video decoder displays the received data on the specified outputs. A client can retrieve the available Receivers using the
  /// GetReceivers command of the Receiver Service.
  @JsonKey(name: 'ReceiverToken')
  final ReferenceToken? receiverToken;

  /// A unique identifier in the display device.
  @JsonKey(name: 'Token')
  final ReferenceToken token;
  PaneConfiguration({
    this.paneName,
    this.audioOutputToken,
    this.audioSourceToken,
    this.audioEncoderConfiguration,
    this.receiverToken,
    required this.token,
  });
}

/// A pane layout describes one Video window of a display. It links a pane configuration to a region of the screen.
@JsonSerializable()
class PaneLayout {
  /// Reference to the configuration of the streaming and coding parameters.
  @JsonKey(name: 'Pane')
  final ReferenceToken pane;

  /// Describes the location and size of the area on the monitor. The area coordinate values are espressed in normalized units [-1.0, 1.0].
  @JsonKey(name: 'Area')
  final Rectangle area;
  PaneLayout({
    required this.pane,
    required this.area,
  });
}

/// A layout describes a set of Video windows that are displayed simultaniously on a display.
@JsonSerializable()
class Layout {
  /// List of panes assembling the display layout.
  @JsonKey(name: 'PaneLayout')
  final PaneLayout paneLayout;
  @JsonKey(name: 'Extension')
  final LayoutExtension? extension_;
  Layout({
    required this.paneLayout,
    this.extension_,
  });
}

class LayoutExtension {}

/// This type contains the Audio and Video coding capabilities of a display service.
@JsonSerializable()
class CodingCapabilities {
  /// If the device supports audio encoding this section describes the supported codecs and their configuration.
  @JsonKey(name: 'AudioEncodingCapabilities')
  final AudioEncoderConfigurationOptions? audioEncodingCapabilities;

  /// If the device supports audio decoding this section describes the supported codecs and their settings.
  @JsonKey(name: 'AudioDecodingCapabilities')
  final AudioDecoderConfigurationOptions? audioDecodingCapabilities;

  /// This section describes the supported video codesc and their configuration.
  @JsonKey(name: 'VideoDecodingCapabilities')
  final VideoDecoderConfigurationOptions videoDecodingCapabilities;
  CodingCapabilities({
    this.audioEncodingCapabilities,
    this.audioDecodingCapabilities,
    required this.videoDecodingCapabilities,
  });
}

/// The options supported for a display layout.
@JsonSerializable()
class LayoutOptions {
  /// Lists the possible Pane Layouts of the Video Output
  @JsonKey(name: 'PaneLayoutOptions')
  final PaneLayoutOptions paneLayoutOptions;
  @JsonKey(name: 'Extension')
  final LayoutOptionsExtension? extension_;
  LayoutOptions({
    required this.paneLayoutOptions,
    this.extension_,
  });
}

class LayoutOptionsExtension {}

/// Description of a pane layout describing a complete display layout.
@JsonSerializable()
class PaneLayoutOptions {
  /// List of areas assembling a layout. Coordinate values are in the range [-1.0, 1.0].
  @JsonKey(name: 'Area')
  final Rectangle area;
  @JsonKey(name: 'Extension')
  final PaneOptionExtension? extension_;
  PaneLayoutOptions({
    required this.area,
    this.extension_,
  });
}

class PaneOptionExtension {}

///
/// Description of a receiver, including its token and configuration.
///
@JsonSerializable()
class Receiver {
  /// Unique identifier of the receiver.
  @JsonKey(name: 'Token')
  final ReferenceToken token;

  /// Describes the configuration of the receiver.
  @JsonKey(name: 'Configuration')
  final ReceiverConfiguration configuration;
  Receiver({
    required this.token,
    required this.configuration,
  });
}

///
/// Describes the configuration of a receiver.
///
@JsonSerializable()
class ReceiverConfiguration {
  /// The following connection modes are defined:
  @JsonKey(name: 'Mode')
  final ReceiverMode mode;

  /// Details of the URI to which the receiver should connect.
  @JsonKey(name: 'MediaUri')
  final String mediaUri;

  /// Stream connection parameters.
  @JsonKey(name: 'StreamSetup')
  final StreamSetup streamSetup;
  ReceiverConfiguration({
    required this.mode,
    required this.mediaUri,
    required this.streamSetup,
  });
}

///
/// Specifies a receiver connection mode.
///
enum ReceiverMode {
  @JsonValue("AutoConnect")
  AutoConnect,
  @JsonValue("AlwaysConnect")
  AlwaysConnect,
  @JsonValue("NeverConnect")
  NeverConnect,
  @JsonValue("Unknown")
  Unknown,
}

///
/// Specifies the current connection state of the receiver.
///
enum ReceiverState {
  @JsonValue("NotConnected")
  NotConnected,
  @JsonValue("Connecting")
  Connecting,
  @JsonValue("Connected")
  Connected,
  @JsonValue("Unknown")
  Unknown,
}

///
/// Contains information about a receiver's current state.
///
@JsonSerializable()
class ReceiverStateInformation {
  /// The connection state of the receiver may have one of the following states:
  @JsonKey(name: 'State')
  final ReceiverState state;

  /// Indicates whether or not the receiver was created automatically.
  @JsonKey(name: 'AutoCreated')
  final bool autoCreated;
  ReceiverStateInformation({
    required this.state,
    required this.autoCreated,
  });
}

@JsonSerializable()
class ReceiverReference {
  @JsonKey(name: 'val')
  final ReferenceToken val;
  ReceiverReference({
    required this.val,
  });
}

@JsonSerializable()
class RecordingReference {
  @JsonKey(name: 'val')
  final ReferenceToken val;
  RecordingReference({
    required this.val,
  });
}

@JsonSerializable()
class SourceReference {
  @JsonKey(name: 'Token')
  final ReferenceToken token;
  @JsonKey(name: 'Type')
  final String? type;
  SourceReference({
    required this.token,
    this.type,
  });
}

@JsonSerializable()
class TrackReference {
  @JsonKey(name: 'val')
  final ReferenceToken val;
  TrackReference({
    required this.val,
  });
}

@JsonSerializable()
class Description {
  @JsonKey(name: 'val')
  final String val;
  Description({
    required this.val,
  });
}

@JsonSerializable()
class DateTimeRange {
  @JsonKey(name: 'From')
  final DateTime from;
  @JsonKey(name: 'Until')
  final DateTime until;
  DateTimeRange({
    required this.from,
    required this.until,
  });
}

@JsonSerializable()
class RecordingSummary {
  /// The earliest point in time where there is recorded data on the device.
  @JsonKey(name: 'DataFrom')
  final DateTime dataFrom;

  /// The most recent point in time where there is recorded data on the device.
  @JsonKey(name: 'DataUntil')
  final DateTime dataUntil;

  /// The device contains this many recordings.
  @JsonKey(name: 'NumberRecordings')
  final int numberRecordings;
  RecordingSummary({
    required this.dataFrom,
    required this.dataUntil,
    required this.numberRecordings,
  });
}

/// A structure for defining a limited scope when searching in recorded data.
@JsonSerializable()
class SearchScope {
  /// A list of sources that are included in the scope. If this list is included, only data from one of these sources shall be searched.
  @JsonKey(name: 'IncludedSources')
  final SourceReference? includedSources;

  /// A list of recordings that are included in the scope. If this list is included, only data from one of these recordings shall be searched.
  @JsonKey(name: 'IncludedRecordings')
  final RecordingReference? includedRecordings;

  /// An xpath expression used to specify what recordings to search. Only those recordings with an RecordingInformation structure that matches the filter shall be searched.
  @JsonKey(name: 'RecordingInformationFilter')
  final XPathExpression? recordingInformationFilter;

  /// Extension point
  @JsonKey(name: 'Extension')
  final SearchScopeExtension? extension_;
  SearchScope({
    this.includedSources,
    this.includedRecordings,
    this.recordingInformationFilter,
    this.extension_,
  });
}

class SearchScopeExtension {}

class EventFilter {}

@JsonSerializable()
class PTZPositionFilter {
  /// The lower boundary of the PTZ volume to look for.
  @JsonKey(name: 'MinPosition')
  final PTZVector minPosition;

  /// The upper boundary of the PTZ volume to look for.
  @JsonKey(name: 'MaxPosition')
  final PTZVector maxPosition;

  /// If true, search for when entering the specified PTZ volume.
  @JsonKey(name: 'EnterOrExit')
  final bool enterOrExit;
  PTZPositionFilter({
    required this.minPosition,
    required this.maxPosition,
    required this.enterOrExit,
  });
}

@JsonSerializable()
class MetadataFilter {
  @JsonKey(name: 'MetadataStreamFilter')
  final XPathExpression metadataStreamFilter;
  MetadataFilter({
    required this.metadataStreamFilter,
  });
}

@JsonSerializable()
class XPathExpression {
  @JsonKey(name: 'val')
  final String val;
  XPathExpression({
    required this.val,
  });
}

@JsonSerializable()
class FindRecordingResultList {
  /// The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.
  @JsonKey(name: 'SearchState')
  final SearchState searchState;

  /// A RecordingInformation structure for each found recording matching the search.
  @JsonKey(name: 'RecordingInformation')
  final RecordingInformation? recordingInformation;
  FindRecordingResultList({
    required this.searchState,
    this.recordingInformation,
  });
}

@JsonSerializable()
class FindEventResultList {
  /// The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.
  @JsonKey(name: 'SearchState')
  final SearchState searchState;

  /// A FindEventResult structure for each found event matching the search.
  @JsonKey(name: 'Result')
  final FindEventResult? result;
  FindEventResultList({
    required this.searchState,
    this.result,
  });
}

@JsonSerializable()
class FindEventResult {
  /// The recording where this event was found. Empty string if no recording is associated with this event.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// A reference to the track where this event was found. Empty string if no track is associated with this event.
  @JsonKey(name: 'TrackToken')
  final TrackReference trackToken;

  /// The time when the event occured.
  @JsonKey(name: 'Time')
  final DateTime time;

  /// The description of the event.
  @JsonKey(name: 'Event')
  final NotificationMessageHolderType event;

  /// If true, indicates that the event is a virtual event generated for this particular search session to give the state of a property at the start time of the search.
  @JsonKey(name: 'StartStateEvent')
  final bool startStateEvent;
  FindEventResult({
    required this.recordingToken,
    required this.trackToken,
    required this.time,
    required this.event,
    required this.startStateEvent,
  });
}

@JsonSerializable()
class FindPTZPositionResultList {
  /// The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.
  @JsonKey(name: 'SearchState')
  final SearchState searchState;

  /// A FindPTZPositionResult structure for each found PTZ position matching the search.
  @JsonKey(name: 'Result')
  final FindPTZPositionResult? result;
  FindPTZPositionResultList({
    required this.searchState,
    this.result,
  });
}

@JsonSerializable()
class FindPTZPositionResult {
  /// A reference to the recording containing the PTZ position.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// A reference to the metadata track containing the PTZ position.
  @JsonKey(name: 'TrackToken')
  final TrackReference trackToken;

  /// The time when the PTZ position was valid.
  @JsonKey(name: 'Time')
  final DateTime time;

  /// The PTZ position.
  @JsonKey(name: 'Position')
  final PTZVector position;
  FindPTZPositionResult({
    required this.recordingToken,
    required this.trackToken,
    required this.time,
    required this.position,
  });
}

@JsonSerializable()
class FindMetadataResultList {
  /// The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.
  @JsonKey(name: 'SearchState')
  final SearchState searchState;

  /// A FindMetadataResult structure for each found set of Metadata matching the search.
  @JsonKey(name: 'Result')
  final FindMetadataResult? result;
  FindMetadataResultList({
    required this.searchState,
    this.result,
  });
}

@JsonSerializable()
class FindMetadataResult {
  /// A reference to the recording containing the metadata.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// A reference to the metadata track containing the matching metadata.
  @JsonKey(name: 'TrackToken')
  final TrackReference trackToken;

  /// The point in time when the matching metadata occurs in the metadata track.
  @JsonKey(name: 'Time')
  final DateTime time;
  FindMetadataResult({
    required this.recordingToken,
    required this.trackToken,
    required this.time,
  });
}

enum SearchState {
  @JsonValue("Queued")
  Queued,
  @JsonValue("Searching")
  Searching,
  @JsonValue("Completed")
  Completed,
  @JsonValue("Unknown")
  Unknown,
}

@JsonSerializable()
class JobToken {
  @JsonKey(name: 'val')
  final ReferenceToken val;
  JobToken({
    required this.val,
  });
}

@JsonSerializable()
class RecordingInformation {
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  ///
  /// Information about the source of the recording. This gives a description of where the data in the recording comes from. Since a single
  /// recording is intended to record related material, there is just one source. It is indicates the physical location or the
  /// major data source for the recording. Currently the recordingconfiguration cannot describe each individual data source.
  ///
  @JsonKey(name: 'Source')
  final RecordingSourceInformation source;
  @JsonKey(name: 'EarliestRecording')
  final DateTime? earliestRecording;
  @JsonKey(name: 'LatestRecording')
  final DateTime? latestRecording;
  @JsonKey(name: 'Content')
  final Description content;

  /// Basic information about the track. Note that a track may represent a single contiguous time span or consist of multiple slices.
  @JsonKey(name: 'Track')
  final TrackInformation? track;
  @JsonKey(name: 'RecordingStatus')
  final RecordingStatus recordingStatus;
  RecordingInformation({
    required this.recordingToken,
    required this.source,
    this.earliestRecording,
    this.latestRecording,
    required this.content,
    this.track,
    required this.recordingStatus,
  });
}

///
/// A set of informative desciptions of a data source. The Search searvice allows a client to filter on recordings based on information in this structure.
///
@JsonSerializable()
class RecordingSourceInformation {
  ///
  /// Identifier for the source chosen by the client that creates the structure.
  /// This identifier is opaque to the device. Clients may use any type of URI for this field. A device shall support at least 128 characters.
  @JsonKey(name: 'SourceId')
  final String sourceId;

  /// Informative user readable name of the source, e.g. "Camera23". A device shall support at least 20 characters.
  @JsonKey(name: 'Name')
  final String name;

  /// Informative description of the physical location of the source, e.g. the coordinates on a map.
  @JsonKey(name: 'Location')
  final Description location;

  /// Informative description of the source.
  @JsonKey(name: 'Description')
  final Description description;

  /// URI provided by the service supplying data to be recorded. A device shall support at least 128 characters.
  @JsonKey(name: 'Address')
  final String address;
  RecordingSourceInformation({
    required this.sourceId,
    required this.name,
    required this.location,
    required this.description,
    required this.address,
  });
}

enum RecordingStatus {
  @JsonValue("Initiated")
  Initiated,
  @JsonValue("Recording")
  Recording,
  @JsonValue("Stopped")
  Stopped,
  @JsonValue("Removing")
  Removing,
  @JsonValue("Removed")
  Removed,
  @JsonValue("Unknown")
  Unknown,
}

@JsonSerializable()
class TrackInformation {
  @JsonKey(name: 'TrackToken')
  final TrackReference trackToken;

  /// Type of the track: "Video", "Audio" or "Metadata".
  /// The track shall only be able to hold data of that type.
  @JsonKey(name: 'TrackType')
  final TrackType trackType;

  /// Informative description of the contents of the track.
  @JsonKey(name: 'Description')
  final Description description;

  /// The start date and time of the oldest recorded data in the track.
  @JsonKey(name: 'DataFrom')
  final DateTime dataFrom;

  /// The stop date and time of the newest recorded data in the track.
  @JsonKey(name: 'DataTo')
  final DateTime dataTo;
  TrackInformation({
    required this.trackToken,
    required this.trackType,
    required this.description,
    required this.dataFrom,
    required this.dataTo,
  });
}

enum TrackType {
  @JsonValue("Video")
  Video,
  @JsonValue("Audio")
  Audio,
  @JsonValue("Metadata")
  Metadata,
  @JsonValue("Extended")
  Extended,
}

/// A set of media attributes valid for a recording at a point in time or for a time interval.
@JsonSerializable()
class MediaAttributes {
  /// A reference to the recording that has these attributes.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// A set of attributes for each track.
  @JsonKey(name: 'TrackAttributes')
  final TrackAttributes? trackAttributes;

  /// The attributes are valid from this point in time in the recording.
  @JsonKey(name: 'From')
  final DateTime from;

  /// The attributes are valid until this point in time in the recording. Can be equal to 'From' to indicate that the attributes are only known to be valid for this particular point in time.
  @JsonKey(name: 'Until')
  final DateTime until;
  MediaAttributes({
    required this.recordingToken,
    this.trackAttributes,
    required this.from,
    required this.until,
  });
}

@JsonSerializable()
class TrackAttributes {
  /// The basic information about the track. Note that a track may represent a single contiguous time span or consist of multiple slices.
  @JsonKey(name: 'TrackInformation')
  final TrackInformation trackInformation;

  /// If the track is a video track, exactly one of this structure shall be present and contain the video attributes.
  @JsonKey(name: 'VideoAttributes')
  final VideoAttributes? videoAttributes;

  /// If the track is an audio track, exactly one of this structure shall be present and contain the audio attributes.
  @JsonKey(name: 'AudioAttributes')
  final AudioAttributes? audioAttributes;

  /// If the track is an metadata track, exactly one of this structure shall be present and contain the metadata attributes.
  @JsonKey(name: 'MetadataAttributes')
  final MetadataAttributes? metadataAttributes;

  ///
  @JsonKey(name: 'Extension')
  final TrackAttributesExtension? extension_;
  TrackAttributes({
    required this.trackInformation,
    this.videoAttributes,
    this.audioAttributes,
    this.metadataAttributes,
    this.extension_,
  });
}

class TrackAttributesExtension {}

@JsonSerializable()
class VideoAttributes {
  /// Average bitrate in kbps.
  @JsonKey(name: 'Bitrate')
  final int? bitrate;

  /// The width of the video in pixels.
  @JsonKey(name: 'Width')
  final int width;

  /// The height of the video in pixels.
  @JsonKey(name: 'Height')
  final int height;

  /// Video encoding of the track.  Use value from tt:VideoEncoding for MPEG4. Otherwise use values from tt:VideoEncodingMimeNames and  IANA Media Types.
  @JsonKey(name: 'Encoding')
  final String encoding;

  /// Average framerate in frames per second.
  @JsonKey(name: 'Framerate')
  final double framerate;
  VideoAttributes({
    this.bitrate,
    required this.width,
    required this.height,
    required this.encoding,
    required this.framerate,
  });
}

@JsonSerializable()
class AudioAttributes {
  /// The bitrate in kbps.
  @JsonKey(name: 'Bitrate')
  final int? bitrate;

  /// Audio encoding of the track.  Use values from tt:AudioEncoding for G711 and AAC. Otherwise use values from tt:AudioEncodingMimeNames and  IANA Media Types.
  @JsonKey(name: 'Encoding')
  final String encoding;

  /// The sample rate in kHz.
  @JsonKey(name: 'Samplerate')
  final int samplerate;
  AudioAttributes({
    this.bitrate,
    required this.encoding,
    required this.samplerate,
  });
}

@JsonSerializable()
class MetadataAttributes {
  /// Indicates that there can be PTZ data in the metadata track in the specified time interval.
  @JsonKey(name: 'CanContainPTZ')
  final bool canContainPTZ;

  /// Indicates that there can be analytics data in the metadata track in the specified time interval.
  @JsonKey(name: 'CanContainAnalytics')
  final bool canContainAnalytics;

  /// Indicates that there can be notifications in the metadata track in the specified time interval.
  @JsonKey(name: 'CanContainNotifications')
  final bool canContainNotifications;

  /// List of all PTZ spaces active for recording. Note that events are only recorded on position changes and the actual point of recording may not necessarily contain an event of the specified type.
  @JsonKey(name: 'PtzSpaces')
  final StringAttrList ptzSpaces;
  MetadataAttributes({
    required this.canContainPTZ,
    required this.canContainAnalytics,
    required this.canContainNotifications,
    required this.ptzSpaces,
  });
}

@JsonSerializable()
class RecordingJobReference {
  @JsonKey(name: 'val')
  final ReferenceToken val;
  RecordingJobReference({
    required this.val,
  });
}

@JsonSerializable()
class RecordingConfiguration {
  /// Information about the source of the recording.
  @JsonKey(name: 'Source')
  final RecordingSourceInformation source;

  /// Informative description of the source.
  @JsonKey(name: 'Content')
  final Description content;

  /// Sspecifies the maximum time that data in any track within the
  /// recording shall be stored. The device shall delete any data older than the maximum retention
  /// time. Such data shall not be accessible anymore. If the MaximumRetentionPeriod is set to 0,
  /// the device shall not limit the retention time of stored data, except by resource constraints.
  /// Whatever the value of MaximumRetentionTime, the device may automatically delete
  /// recordings to free up storage space for new recordings.
  @JsonKey(name: 'MaximumRetentionTime')
  final Duration maximumRetentionTime;
  RecordingConfiguration({
    required this.source,
    required this.content,
    required this.maximumRetentionTime,
  });
}

@JsonSerializable()
class TrackConfiguration {
  /// Type of the track. It shall be equal to the strings “Video”,
  /// “Audio” or “Metadata”. The track shall only be able to hold data of that type.
  @JsonKey(name: 'TrackType')
  final TrackType trackType;

  /// Informative description of the track.
  @JsonKey(name: 'Description')
  final Description description;
  TrackConfiguration({
    required this.trackType,
    required this.description,
  });
}

@JsonSerializable()
class GetRecordingsResponseItem {
  /// Token of the recording.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// Configuration of the recording.
  @JsonKey(name: 'Configuration')
  final RecordingConfiguration configuration;

  /// List of tracks.
  @JsonKey(name: 'Tracks')
  final GetTracksResponseList tracks;
  GetRecordingsResponseItem({
    required this.recordingToken,
    required this.configuration,
    required this.tracks,
  });
}

@JsonSerializable()
class GetTracksResponseList {
  /// Configuration of a track.
  @JsonKey(name: 'Track')
  final GetTracksResponseItem? track;
  GetTracksResponseList({
    this.track,
  });
}

@JsonSerializable()
class GetTracksResponseItem {
  /// Token of the track.
  @JsonKey(name: 'TrackToken')
  final TrackReference trackToken;

  /// Configuration of the track.
  @JsonKey(name: 'Configuration')
  final TrackConfiguration configuration;
  GetTracksResponseItem({
    required this.trackToken,
    required this.configuration,
  });
}

@JsonSerializable()
class RecordingJobConfiguration {
  /// Identifies the recording to which this job shall store the received data.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// The mode of the job. If it is idle, nothing shall happen. If it is active, the device shall try
  /// to obtain data from the receivers. A client shall use GetRecordingJobState to determine if data transfer is really taking place.
  /// The only valid values for Mode shall be “Idle” and “Active”.
  @JsonKey(name: 'Mode')
  final RecordingJobMode mode;

  /// This shall be a non-negative number. If there are multiple recording jobs that store data to
  /// the same track, the device will only store the data for the recording job with the highest
  /// priority. The priority is specified per recording job, but the device shall determine the priority
  /// of each track individually. If there are two recording jobs with the same priority, the device
  /// shall record the data corresponding to the recording job that was activated the latest.
  @JsonKey(name: 'Priority')
  final int priority;

  /// Source of the recording.
  @JsonKey(name: 'Source')
  final RecordingJobSource? source;
  @JsonKey(name: 'Extension')
  final RecordingJobConfigurationExtension? extension_;
  RecordingJobConfiguration({
    required this.recordingToken,
    required this.mode,
    required this.priority,
    this.source,
    this.extension_,
  });
}

@JsonSerializable()
class RecordingJobMode {
  @JsonKey(name: 'val')
  final String val;
  RecordingJobMode({
    required this.val,
  });
}

class RecordingJobConfigurationExtension {}

@JsonSerializable()
class RecordingJobSource {
  /// This field shall be a reference to the source of the data. The type of the source
  /// is determined by the attribute Type in the SourceToken structure. If Type is
  /// http://www.onvif.org/ver10/schema/Receiver, the token is a ReceiverReference. In this case
  /// the device shall receive the data over the network. If Type is
  /// http://www.onvif.org/ver10/schema/Profile, the token identifies a media profile, instructing the
  /// device to obtain data from a profile that exists on the local device.
  @JsonKey(name: 'SourceToken')
  final SourceReference? sourceToken;

  /// If this field is TRUE, and if the SourceToken is omitted, the device
  /// shall create a receiver object (through the receiver service) and assign the
  /// ReceiverReference to the SourceToken field. When retrieving the RecordingJobConfiguration
  /// from the device, the AutoCreateReceiver field shall never be present.
  @JsonKey(name: 'AutoCreateReceiver')
  final bool? autoCreateReceiver;

  /// List of tracks associated with the recording.
  @JsonKey(name: 'Tracks')
  final RecordingJobTrack? tracks;
  @JsonKey(name: 'Extension')
  final RecordingJobSourceExtension? extension_;
  RecordingJobSource({
    this.sourceToken,
    this.autoCreateReceiver,
    this.tracks,
    this.extension_,
  });
}

class RecordingJobSourceExtension {}

@JsonSerializable()
class RecordingJobTrack {
  /// If the received RTSP stream contains multiple tracks of the same type, the
  /// SourceTag differentiates between those Tracks. This field can be ignored in case of recording a local source.
  @JsonKey(name: 'SourceTag')
  final String sourceTag;

  /// The destination is the tracktoken of the track to which the device shall store the
  /// received data.
  @JsonKey(name: 'Destination')
  final TrackReference destination;
  RecordingJobTrack({
    required this.sourceTag,
    required this.destination,
  });
}

@JsonSerializable()
class RecordingJobStateInformation {
  /// Identification of the recording that the recording job records to.
  @JsonKey(name: 'RecordingToken')
  final RecordingReference recordingToken;

  /// Holds the aggregated state over the whole RecordingJobInformation structure.
  @JsonKey(name: 'State')
  final RecordingJobState state;

  /// Identifies the data source of the recording job.
  @JsonKey(name: 'Sources')
  final RecordingJobStateSource? sources;
  @JsonKey(name: 'Extension')
  final RecordingJobStateInformationExtension? extension_;
  RecordingJobStateInformation({
    required this.recordingToken,
    required this.state,
    this.sources,
    this.extension_,
  });
}

class RecordingJobStateInformationExtension {}

@JsonSerializable()
class RecordingJobState {
  @JsonKey(name: 'val')
  final String val;
  RecordingJobState({
    required this.val,
  });
}

@JsonSerializable()
class RecordingJobStateSource {
  /// Identifies the data source of the recording job.
  @JsonKey(name: 'SourceToken')
  final SourceReference sourceToken;

  /// Holds the aggregated state over all substructures of RecordingJobStateSource.
  @JsonKey(name: 'State')
  final RecordingJobState state;

  /// List of track items.
  @JsonKey(name: 'Tracks')
  final RecordingJobStateTracks tracks;
  RecordingJobStateSource({
    required this.sourceToken,
    required this.state,
    required this.tracks,
  });
}

@JsonSerializable()
class RecordingJobStateTracks {
  @JsonKey(name: 'Track')
  final RecordingJobStateTrack? track;
  RecordingJobStateTracks({
    this.track,
  });
}

@JsonSerializable()
class RecordingJobStateTrack {
  /// Identifies the track of the data source that provides the data.
  @JsonKey(name: 'SourceTag')
  final String sourceTag;

  /// Indicates the destination track.
  @JsonKey(name: 'Destination')
  final TrackReference destination;

  /// Optionally holds an implementation defined string value that describes the error.
  /// The string should be in the English language.
  @JsonKey(name: 'Error')
  final String? error;

  /// Provides the job state of the track. The valid
  /// values of state shall be “Idle”, “Active” and “Error”. If state equals “Error”, the Error field may be filled in with an implementation defined value.
  @JsonKey(name: 'State')
  final RecordingJobState state;
  RecordingJobStateTrack({
    required this.sourceTag,
    required this.destination,
    this.error,
    required this.state,
  });
}

@JsonSerializable()
class GetRecordingJobsResponseItem {
  @JsonKey(name: 'JobToken')
  final RecordingJobReference jobToken;
  @JsonKey(name: 'JobConfiguration')
  final RecordingJobConfiguration jobConfiguration;
  GetRecordingJobsResponseItem({
    required this.jobToken,
    required this.jobConfiguration,
  });
}

///
///       Configuration parameters for the replay service.
///
@JsonSerializable()
class ReplayConfiguration {
  /// The RTSP session timeout.
  @JsonKey(name: 'SessionTimeout')
  final Duration sessionTimeout;
  ReplayConfiguration({
    required this.sessionTimeout,
  });
}

class AnalyticsEngine {}

@JsonSerializable()
class AnalyticsDeviceEngineConfiguration {
  @JsonKey(name: 'EngineConfiguration')
  final EngineConfiguration engineConfiguration;
  @JsonKey(name: 'Extension')
  final AnalyticsDeviceEngineConfigurationExtension? extension_;
  AnalyticsDeviceEngineConfiguration({
    required this.engineConfiguration,
    this.extension_,
  });
}

class AnalyticsDeviceEngineConfigurationExtension {}

@JsonSerializable()
class EngineConfiguration {
  @JsonKey(name: 'VideoAnalyticsConfiguration')
  final VideoAnalyticsConfiguration videoAnalyticsConfiguration;
  @JsonKey(name: 'AnalyticsEngineInputInfo')
  final AnalyticsEngineInputInfo analyticsEngineInputInfo;
  EngineConfiguration({
    required this.videoAnalyticsConfiguration,
    required this.analyticsEngineInputInfo,
  });
}

@JsonSerializable()
class AnalyticsEngineInputInfo {
  @JsonKey(name: 'InputInfo')
  final Config? inputInfo;
  @JsonKey(name: 'Extension')
  final AnalyticsEngineInputInfoExtension? extension_;
  AnalyticsEngineInputInfo({
    this.inputInfo,
    this.extension_,
  });
}

class AnalyticsEngineInputInfoExtension {}

class AnalyticsEngineInput {}

@JsonSerializable()
class SourceIdentification {
  @JsonKey(name: 'Name')
  final String name;
  @JsonKey(name: 'Token')
  final ReferenceToken token;
  @JsonKey(name: 'Extension')
  final SourceIdentificationExtension? extension_;
  SourceIdentification({
    required this.name,
    required this.token,
    this.extension_,
  });
}

class SourceIdentificationExtension {}

@JsonSerializable()
class MetadataInput {
  @JsonKey(name: 'MetadataConfig')
  final Config? metadataConfig;
  @JsonKey(name: 'Extension')
  final MetadataInputExtension? extension_;
  MetadataInput({
    this.metadataConfig,
    this.extension_,
  });
}

class MetadataInputExtension {}

class AnalyticsEngineControl {}

enum ModeOfOperation {
  @JsonValue("Idle")
  Idle,
  @JsonValue("Active")
  Active,
  @JsonValue("Unknown")
  Unknown,
}

@JsonSerializable()
class AnalyticsStateInformation {
  /// Token of the control object whose status is requested.
  @JsonKey(name: 'AnalyticsEngineControlToken')
  final ReferenceToken analyticsEngineControlToken;
  @JsonKey(name: 'State')
  final AnalyticsState state;
  AnalyticsStateInformation({
    required this.analyticsEngineControlToken,
    required this.state,
  });
}

@JsonSerializable()
class AnalyticsState {
  @JsonKey(name: 'Error')
  final String? error;
  @JsonKey(name: 'State')
  final String state;
  AnalyticsState({
    this.error,
    required this.state,
  });
}

/// Action Engine Event Payload data structure contains the information about the ONVIF command invocations. Since this event could be generated by other or proprietary actions, the command invocation specific fields are defined as optional and additional extension mechanism is provided for future or additional action definitions.
@JsonSerializable()
class ActionEngineEventPayload {
  /// Request Message
  @JsonKey(name: 'RequestInfo')
  final Envelope? requestInfo;

  /// Response Message
  @JsonKey(name: 'ResponseInfo')
  final Envelope? responseInfo;

  /// Fault Message
  @JsonKey(name: 'Fault')
  final Fault? fault;
  @JsonKey(name: 'Extension')
  final ActionEngineEventPayloadExtension? extension_;
  ActionEngineEventPayload({
    this.requestInfo,
    this.responseInfo,
    this.fault,
    this.extension_,
  });
}

class ActionEngineEventPayloadExtension {}

///
///   AudioClassType acceptable values are;
///    gun_shot, scream, glass_breaking, tire_screech
///
@JsonSerializable()
class AudioClassType {
  @JsonKey(name: 'val')
  final String val;
  AudioClassType({
    required this.val,
  });
}

@JsonSerializable()
class AudioClassCandidate {
  /// Indicates audio class label
  @JsonKey(name: 'Type')
  final AudioClassType type;

  /// A likelihood/probability that the corresponding audio event belongs to this class. The sum of the likelihoods shall NOT exceed 1
  @JsonKey(name: 'Likelihood')
  final double likelihood;
  AudioClassCandidate({
    required this.type,
    required this.likelihood,
  });
}

@JsonSerializable()
class AudioClassDescriptor {
  /// Array of audio class label and class probability
  @JsonKey(name: 'ClassCandidate')
  final AudioClassCandidate? classCandidate;
  @JsonKey(name: 'Extension')
  final AudioClassDescriptorExtension? extension_;
  AudioClassDescriptor({
    this.classCandidate,
    this.extension_,
  });
}

class AudioClassDescriptorExtension {}

@JsonSerializable()
class ActiveConnection {
  @JsonKey(name: 'CurrentBitrate')
  final double currentBitrate;
  @JsonKey(name: 'CurrentFps')
  final double currentFps;
  ActiveConnection({
    required this.currentBitrate,
    required this.currentFps,
  });
}

@JsonSerializable()
class ProfileStatus {
  @JsonKey(name: 'ActiveConnections')
  final ActiveConnection? activeConnections;
  @JsonKey(name: 'Extension')
  final ProfileStatusExtension? extension_;
  ProfileStatus({
    this.activeConnections,
    this.extension_,
  });
}

class ProfileStatusExtension {}

@JsonSerializable()
class OSDReference {
  @JsonKey(name: 'value')
  final ReferenceToken value;
  OSDReference({
    required this.value,
  });
}

enum OSDType {
  @JsonValue("Text")
  Text,
  @JsonValue("Image")
  Image,
  @JsonValue("Extended")
  Extended,
}

@JsonSerializable()
class OSDPosConfiguration {
  /// For OSD position type, following are the pre-defined: UpperLeft
  /// UpperRight
  /// LowerLeft
  /// LowerRight
  /// Custom
  ///
  @JsonKey(name: 'Type')
  final String type;
  @JsonKey(name: 'Pos')
  final Vector? pos;
  @JsonKey(name: 'Extension')
  final OSDPosConfigurationExtension? extension_;
  OSDPosConfiguration({
    required this.type,
    this.pos,
    this.extension_,
  });
}

class OSDPosConfigurationExtension {}

/// The value range of "Transparent" could be defined by vendors only should follow this rule: the minimum value means non-transparent and the maximum value maens fully transparent.
@JsonSerializable()
class OSDColor {
  @JsonKey(name: 'Color')
  final Color color;
  @JsonKey(name: 'Transparent')
  final int? transparent;
  OSDColor({
    required this.color,
    this.transparent,
  });
}

@JsonSerializable()
class OSDTextConfiguration {
  ///
  /// The following OSD Text Type are defined:
  /// Plain - The Plain type means the OSD is shown as a text string which defined in the "PlainText" item.
  /// Date - The Date type means the OSD is shown as a date, format of which should be present in the "DateFormat" item.
  /// Time - The Time type means the OSD is shown as a time, format of which should be present in the "TimeFormat" item.
  /// DateAndTime - The DateAndTime type means the OSD is shown as date and time, format of which should be present in the "DateFormat" and the "TimeFormat" item.
  ///
  ///
  @JsonKey(name: 'Type')
  final String type;

  ///
  /// List of supported OSD date formats. This element shall be present when the value of Type field has Date or DateAndTime. The following DateFormat are defined:
  /// M/d/yyyy - e.g. 3/6/2013
  /// MM/dd/yyyy - e.g. 03/06/2013
  /// dd/MM/yyyy - e.g. 06/03/2013
  /// yyyy/MM/dd - e.g. 2013/03/06
  /// yyyy-MM-dd - e.g. 2013-06-03
  /// dddd, MMMM dd, yyyy - e.g. Wednesday, March 06, 2013
  /// MMMM dd, yyyy - e.g. March 06, 2013
  /// dd MMMM, yyyy - e.g. 06 March, 2013
  ///
  ///
  @JsonKey(name: 'DateFormat')
  final String? dateFormat;

  ///
  /// List of supported OSD time formats. This element shall be present when the value of Type field has Time or DateAndTime. The following TimeFormat are defined:
  /// h:mm:ss tt - e.g. 2:14:21 PM
  /// hh:mm:ss tt - e.g. 02:14:21 PM
  /// H:mm:ss - e.g. 14:14:21
  /// HH:mm:ss - e.g. 14:14:21
  ///
  ///
  @JsonKey(name: 'TimeFormat')
  final String? timeFormat;

  /// Font size of the text in pt.
  @JsonKey(name: 'FontSize')
  final int? fontSize;

  /// Font color of the text.
  @JsonKey(name: 'FontColor')
  final OSDColor? fontColor;

  /// Background color of the text.
  @JsonKey(name: 'BackgroundColor')
  final OSDColor? backgroundColor;

  /// The content of text to be displayed.
  @JsonKey(name: 'PlainText')
  final String? plainText;
  @JsonKey(name: 'Extension')
  final OSDTextConfigurationExtension? extension_;

  /// This flag is applicable for Type Plain and defaults to true. When set to false the PlainText content will not be persistent across device reboots.
  @JsonKey(name: 'IsPersistentText')
  final bool? isPersistentText;
  OSDTextConfiguration({
    required this.type,
    this.dateFormat,
    this.timeFormat,
    this.fontSize,
    this.fontColor,
    this.backgroundColor,
    this.plainText,
    this.extension_,
    this.isPersistentText,
  });
}

class OSDTextConfigurationExtension {}

@JsonSerializable()
class OSDImgConfiguration {
  /// The URI of the image which to be displayed.
  @JsonKey(name: 'ImgPath')
  final String imgPath;
  @JsonKey(name: 'Extension')
  final OSDImgConfigurationExtension? extension_;
  OSDImgConfiguration({
    required this.imgPath,
    this.extension_,
  });
}

class OSDImgConfigurationExtension {}

@JsonSerializable()
class ColorspaceRange {
  @JsonKey(name: 'X')
  final FloatRange x;
  @JsonKey(name: 'Y')
  final FloatRange y;
  @JsonKey(name: 'Z')
  final FloatRange z;

  ///
  /// Acceptable values are the same as in tt:Color.
  ///
  @JsonKey(name: 'Colorspace')
  final String colorspace;
  ColorspaceRange({
    required this.x,
    required this.y,
    required this.z,
    required this.colorspace,
  });
}

///
/// Describe the colors supported. Either list each color or define the range of color values.
///
class ColorOptions {}

/// Describe the option of the color and its transparency.
@JsonSerializable()
class OSDColorOptions {
  /// Optional list of supported colors.
  @JsonKey(name: 'Color')
  final ColorOptions? color;

  /// Range of the transparent level. Larger means more tranparent.
  @JsonKey(name: 'Transparent')
  final IntRange? transparent;
  @JsonKey(name: 'Extension')
  final OSDColorOptionsExtension? extension_;
  OSDColorOptions({
    this.color,
    this.transparent,
    this.extension_,
  });
}

class OSDColorOptionsExtension {}

@JsonSerializable()
class OSDTextOptions {
  /// List of supported OSD text type. When a device indicates the supported number relating to Text type in MaximumNumberOfOSDs, the type shall be presented.
  @JsonKey(name: 'Type')
  final String type;

  /// Range of the font size value.
  @JsonKey(name: 'FontSizeRange')
  final IntRange? fontSizeRange;

  /// List of supported date format.
  @JsonKey(name: 'DateFormat')
  final String? dateFormat;

  /// List of supported time format.
  @JsonKey(name: 'TimeFormat')
  final String? timeFormat;

  /// List of supported font color.
  @JsonKey(name: 'FontColor')
  final OSDColorOptions? fontColor;

  /// List of supported background color.
  @JsonKey(name: 'BackgroundColor')
  final OSDColorOptions? backgroundColor;
  @JsonKey(name: 'Extension')
  final OSDTextOptionsExtension? extension_;
  OSDTextOptions({
    required this.type,
    this.fontSizeRange,
    this.dateFormat,
    this.timeFormat,
    this.fontColor,
    this.backgroundColor,
    this.extension_,
  });
}

class OSDTextOptionsExtension {}

@JsonSerializable()
class OSDImgOptions {
  /// List of available image URIs.
  @JsonKey(name: 'ImagePath')
  final String imagePath;
  @JsonKey(name: 'Extension')
  final OSDImgOptionsExtension? extension_;

  /// List of supported image MIME types, such as "image/png".
  @JsonKey(name: 'FormatsSupported')
  final StringAttrList formatsSupported;

  /// The maximum size (in bytes) of the image that can be uploaded.
  @JsonKey(name: 'MaxSize')
  final int maxSize;

  /// The maximum width (in pixels) of the image that can be uploaded.
  @JsonKey(name: 'MaxWidth')
  final int maxWidth;

  /// The maximum height (in pixels) of the image that can be uploaded.
  @JsonKey(name: 'MaxHeight')
  final int maxHeight;
  OSDImgOptions({
    required this.imagePath,
    this.extension_,
    required this.formatsSupported,
    required this.maxSize,
    required this.maxWidth,
    required this.maxHeight,
  });
}

class OSDImgOptionsExtension {}

class OSDConfiguration {}

class OSDConfigurationExtension {}

@JsonSerializable()
class MaximumNumberOfOSDs {
  @JsonKey(name: 'Total')
  final int total;
  @JsonKey(name: 'Image')
  final int image;
  @JsonKey(name: 'PlainText')
  final int plainText;
  @JsonKey(name: 'Date')
  final int date;
  @JsonKey(name: 'Time')
  final int time;
  @JsonKey(name: 'DateAndTime')
  final int dateAndTime;
  MaximumNumberOfOSDs({
    required this.total,
    required this.image,
    required this.plainText,
    required this.date,
    required this.time,
    required this.dateAndTime,
  });
}

@JsonSerializable()
class OSDConfigurationOptions {
  /// The maximum number of OSD configurations supported for the specified video source configuration. If the configuration does not support OSDs, this value shall be zero and the Type and PositionOption elements are ignored. If a device limits the number of instances by OSDType, it shall indicate the supported number for each type via the related attribute.
  @JsonKey(name: 'MaximumNumberOfOSDs')
  final MaximumNumberOfOSDs maximumNumberOfOSDs;

  /// List supported type of OSD configuration. When a device indicates the supported number for each types in MaximumNumberOfOSDs, related type shall be presented. A device shall return Option element relating to listed type.
  @JsonKey(name: 'Type')
  final OSDType type;

  /// List available OSD position type. Following are the pre-defined:UpperLeft
  /// UpperRight
  /// LowerLeft
  /// LowerRight
  /// Custom
  ///
  @JsonKey(name: 'PositionOption')
  final String positionOption;

  /// Option of the OSD text configuration. This element shall be returned if the device is signaling the support for Text.
  @JsonKey(name: 'TextOption')
  final OSDTextOptions? textOption;

  /// Option of the OSD image configuration. This element shall be returned if the device is signaling the support for Image.
  @JsonKey(name: 'ImageOption')
  final OSDImgOptions? imageOption;
  @JsonKey(name: 'Extension')
  final OSDConfigurationOptionsExtension? extension_;
  OSDConfigurationOptions({
    required this.maximumNumberOfOSDs,
    required this.type,
    required this.positionOption,
    this.textOption,
    this.imageOption,
    this.extension_,
  });
}

class OSDConfigurationOptionsExtension {}

@JsonSerializable()
class FileProgress {
  /// Exported file name
  @JsonKey(name: 'FileName')
  final String fileName;

  /// Normalized percentage completion for uploading the exported file
  @JsonKey(name: 'Progress')
  final double progress;
  FileProgress({
    required this.fileName,
    required this.progress,
  });
}

@JsonSerializable()
class ArrayOfFileProgress {
  /// Exported file name and export progress information
  @JsonKey(name: 'FileProgress')
  final FileProgress? fileProgress;
  @JsonKey(name: 'Extension')
  final ArrayOfFileProgressExtension? extension_;
  ArrayOfFileProgress({
    this.fileProgress,
    this.extension_,
  });
}

class ArrayOfFileProgressExtension {}

@JsonSerializable()
class StorageReferencePath {
  /// identifier of an existing Storage Configuration.
  @JsonKey(name: 'StorageToken')
  final ReferenceToken storageToken;

  /// gives the relative directory path on the storage
  @JsonKey(name: 'RelativePath')
  final String? relativePath;
  @JsonKey(name: 'Extension')
  final StorageReferencePathExtension? extension_;
  StorageReferencePath({
    required this.storageToken,
    this.relativePath,
    this.extension_,
  });
}

class StorageReferencePathExtension {}
